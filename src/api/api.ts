/* tslint:disable */
/* eslint-disable */
/**
 * eduVirt
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddVmDto
 */
export interface AddVmDto {
    /**
     * 
     * @type {string}
     * @memberof AddVmDto
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddVmDto
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterDetailsDto
 */
export interface ClusterDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'clusterCpuType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'compatibilityVersion'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterDetailsDto
     */
    'threadsAsCores'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'maxMemoryOverCommit'?: string;
}
/**
 * 
 * @export
 * @interface ClusterGeneralDto
 */
export interface ClusterGeneralDto {
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'clusterCpuType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'compatibilityVersion'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterGeneralDto
     */
    'hostCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterGeneralDto
     */
    'vmCount'?: number;
}
/**
 * 
 * @export
 * @interface CourseAccessKeyDto
 */
export interface CourseAccessKeyDto {
    /**
     * 
     * @type {string}
     * @memberof CourseAccessKeyDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseAccessKeyDto
     */
    'keyValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseAccessKeyDto
     */
    'courseId'?: string;
}
/**
 * 
 * @export
 * @interface CourseBasicDto
 */
export interface CourseBasicDto {
    /**
     * 
     * @type {string}
     * @memberof CourseBasicDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseBasicDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseBasicDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseBasicDto
     */
    'courseType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseBasicDto
     */
    'clusterId'?: string;
}
/**
 * 
 * @export
 * @interface CourseDto
 */
export interface CourseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'courseType'?: CourseDtoCourseTypeEnum;
}

export const CourseDtoCourseTypeEnum = {
    TeamBased: 'TEAM_BASED',
    Solo: 'SOLO'
} as const;

export type CourseDtoCourseTypeEnum = typeof CourseDtoCourseTypeEnum[keyof typeof CourseDtoCourseTypeEnum];

/**
 * 
 * @export
 * @interface CreateCourseDto
 */
export interface CreateCourseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'courseType': CreateCourseDtoCourseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'clusterId': string;
}

export const CreateCourseDtoCourseTypeEnum = {
    TeamBased: 'TEAM_BASED',
    Solo: 'SOLO'
} as const;

export type CreateCourseDtoCourseTypeEnum = typeof CreateCourseDtoCourseTypeEnum[keyof typeof CreateCourseDtoCourseTypeEnum];

/**
 * 
 * @export
 * @interface CreateMaintenanceIntervalDto
 */
export interface CreateMaintenanceIntervalDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'cause': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'beginAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'endAt': string;
}
/**
 * 
 * @export
 * @interface CreateMetricDto
 */
export interface CreateMetricDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricDto
     */
    'category': CreateMetricDtoCategoryEnum;
}

export const CreateMetricDtoCategoryEnum = {
    VolatileMemory: 'VOLATILE_MEMORY',
    NonVolatileMemory: 'NON_VOLATILE_MEMORY',
    Countable: 'COUNTABLE'
} as const;

export type CreateMetricDtoCategoryEnum = typeof CreateMetricDtoCategoryEnum[keyof typeof CreateMetricDtoCategoryEnum];

/**
 * 
 * @export
 * @interface CreateMetricValueDto
 */
export interface CreateMetricValueDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricValueDto
     */
    'metricId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMetricValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CreatePodStatefulDto
 */
export interface CreatePodStatefulDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatefulDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatefulDto
     */
    'resourceGroupId'?: string;
}
/**
 * 
 * @export
 * @interface CreatePodStatelessDto
 */
export interface CreatePodStatelessDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatelessDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatelessDto
     */
    'resourceGroupPoolId'?: string;
}
/**
 * 
 * @export
 * @interface CreateRGPoolDto
 */
export interface CreateRGPoolDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRGPoolDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRGPoolDto
     */
    'courseId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateRGPoolDto
     */
    'maxRent'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateRGPoolDto
     */
    'gracePeriod'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateRGPoolDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRGPoolDto
     */
    'maxRentTime'?: number;
}
/**
 * 
 * @export
 * @interface CreateReservationDto
 */
export interface CreateReservationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateReservationDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReservationDto
     */
    'end': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateReservationDto
     */
    'automaticStartup'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateReservationDto
     */
    'notificationTime'?: number;
}
/**
 * 
 * @export
 * @interface CreateResourceGroupDto
 */
export interface CreateResourceGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceGroupDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateResourceGroupDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateResourceGroupDto
     */
    'maxRentTime'?: number;
}
/**
 * 
 * @export
 * @interface CreateResourceGroupNetworkDto
 */
export interface CreateResourceGroupNetworkDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceGroupNetworkDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateTeamDto
 */
export interface CreateTeamDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamDto
     */
    'keyValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTeamDto
     */
    'maxSize'?: number;
}
/**
 * 
 * @export
 * @interface CreateVlansRangeDto
 */
export interface CreateVlansRangeDto {
    /**
     * 
     * @type {number}
     * @memberof CreateVlansRangeDto
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateVlansRangeDto
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface DetailedResourceGroupPoolDto
 */
export interface DetailedResourceGroupPoolDto {
    /**
     * 
     * @type {string}
     * @memberof DetailedResourceGroupPoolDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailedResourceGroupPoolDto
     */
    'name'?: string;
    /**
     * 
     * @type {CourseDto}
     * @memberof DetailedResourceGroupPoolDto
     */
    'course'?: CourseDto;
    /**
     * 
     * @type {Array<ResourceGroupDto>}
     * @memberof DetailedResourceGroupPoolDto
     */
    'resourceGroups'?: Array<ResourceGroupDto>;
    /**
     * 
     * @type {number}
     * @memberof DetailedResourceGroupPoolDto
     */
    'maxRent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DetailedResourceGroupPoolDto
     */
    'gracePeriod'?: number;
    /**
     * 
     * @type {string}
     * @memberof DetailedResourceGroupPoolDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DetailedResourceGroupPoolDto
     */
    'maxRentTime'?: number;
}
/**
 * 
 * @export
 * @interface EditVmDto
 */
export interface EditVmDto {
    /**
     * 
     * @type {boolean}
     * @memberof EditVmDto
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface EventGeneralDto
 */
export interface EventGeneralDto {
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'severity'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'registeredAt'?: string;
}
/**
 * 
 * @export
 * @interface ExceptionResponse
 */
export interface ExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponse
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface HostDto
 */
export interface HostDto {
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof HostDto
     */
    'cpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof HostDto
     */
    'memory'?: number;
}
/**
 * 
 * @export
 * @interface MaintenanceIntervalDetailsDto
 */
export interface MaintenanceIntervalDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'cause'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'clusterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'beginAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'endAt'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceIntervalDto
 */
export interface MaintenanceIntervalDto {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'cause'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'clusterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'beginAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'endAt'?: string;
}
/**
 * 
 * @export
 * @interface MetricDto
 */
export interface MetricDto {
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'category'?: MetricDtoCategoryEnum;
}

export const MetricDtoCategoryEnum = {
    VolatileMemory: 'VOLATILE_MEMORY',
    NonVolatileMemory: 'NON_VOLATILE_MEMORY',
    Countable: 'COUNTABLE'
} as const;

export type MetricDtoCategoryEnum = typeof MetricDtoCategoryEnum[keyof typeof MetricDtoCategoryEnum];

/**
 * 
 * @export
 * @interface MetricValueDto
 */
export interface MetricValueDto {
    /**
     * 
     * @type {string}
     * @memberof MetricValueDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricValueDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricValueDto
     */
    'category'?: MetricValueDtoCategoryEnum;
    /**
     * 
     * @type {number}
     * @memberof MetricValueDto
     */
    'value'?: number;
}

export const MetricValueDtoCategoryEnum = {
    VolatileMemory: 'VOLATILE_MEMORY',
    NonVolatileMemory: 'NON_VOLATILE_MEMORY',
    Countable: 'COUNTABLE'
} as const;

export type MetricValueDtoCategoryEnum = typeof MetricValueDtoCategoryEnum[keyof typeof MetricValueDtoCategoryEnum];

/**
 * 
 * @export
 * @interface NetworkDto
 */
export interface NetworkDto {
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface NetworkVmConnectionDto
 */
export interface NetworkVmConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof NetworkVmConnectionDto
     */
    'vmId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkVmConnectionDto
     */
    'nicId'?: string;
}
/**
 * 
 * @export
 * @interface NicDto
 */
export interface NicDto {
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'profileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'segmentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'macAddress'?: string;
}
/**
 * 
 * @export
 * @interface PageDtoCourseDto
 */
export interface PageDtoCourseDto {
    /**
     * 
     * @type {Array<CourseDto>}
     * @memberof PageDtoCourseDto
     */
    'items'?: Array<CourseDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoCourseDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoDetailedResourceGroupPoolDto
 */
export interface PageDtoDetailedResourceGroupPoolDto {
    /**
     * 
     * @type {Array<DetailedResourceGroupPoolDto>}
     * @memberof PageDtoDetailedResourceGroupPoolDto
     */
    'items'?: Array<DetailedResourceGroupPoolDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoDetailedResourceGroupPoolDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoMaintenanceIntervalDto
 */
export interface PageDtoMaintenanceIntervalDto {
    /**
     * 
     * @type {Array<MaintenanceIntervalDto>}
     * @memberof PageDtoMaintenanceIntervalDto
     */
    'items'?: Array<MaintenanceIntervalDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoMaintenanceIntervalDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoMetricDto
 */
export interface PageDtoMetricDto {
    /**
     * 
     * @type {Array<MetricDto>}
     * @memberof PageDtoMetricDto
     */
    'items'?: Array<MetricDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoMetricDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoMetricValueDto
 */
export interface PageDtoMetricValueDto {
    /**
     * 
     * @type {Array<MetricValueDto>}
     * @memberof PageDtoMetricValueDto
     */
    'items'?: Array<MetricValueDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoMetricValueDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoReservationDto
 */
export interface PageDtoReservationDto {
    /**
     * 
     * @type {Array<ReservationDto>}
     * @memberof PageDtoReservationDto
     */
    'items'?: Array<ReservationDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoReservationDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageInfoDto
 */
export interface PageInfoDto {
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'elements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'totalElements'?: number;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PodStatefulDetailsDto
 */
export interface PodStatefulDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {ResourceGroupDto}
     * @memberof PodStatefulDetailsDto
     */
    'resourceGroup'?: ResourceGroupDto;
    /**
     * 
     * @type {CourseBasicDto}
     * @memberof PodStatefulDetailsDto
     */
    'course'?: CourseBasicDto;
    /**
     * 
     * @type {TeamDto}
     * @memberof PodStatefulDetailsDto
     */
    'team'?: TeamDto;
}
/**
 * 
 * @export
 * @interface PodStatefulDto
 */
export interface PodStatefulDto {
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'resourceGroupId'?: string;
}
/**
 * 
 * @export
 * @interface PodStatelessDetailsDto
 */
export interface PodStatelessDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof PodStatelessDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {ResourceGroupPoolDto}
     * @memberof PodStatelessDetailsDto
     */
    'resourceGroupPool'?: ResourceGroupPoolDto;
    /**
     * 
     * @type {CourseBasicDto}
     * @memberof PodStatelessDetailsDto
     */
    'course'?: CourseBasicDto;
    /**
     * 
     * @type {TeamDto}
     * @memberof PodStatelessDetailsDto
     */
    'team'?: TeamDto;
}
/**
 * 
 * @export
 * @interface PodStatelessDto
 */
export interface PodStatelessDto {
    /**
     * 
     * @type {string}
     * @memberof PodStatelessDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatelessDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatelessDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatelessDto
     */
    'resourceGroupPoolId'?: string;
}
/**
 * 
 * @export
 * @interface ReservationDetailsDto
 */
export interface ReservationDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {ResourceGroupDto}
     * @memberof ReservationDetailsDto
     */
    'resourceGroup'?: ResourceGroupDto;
    /**
     * 
     * @type {TeamDto}
     * @memberof ReservationDetailsDto
     */
    'team'?: TeamDto;
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'end'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReservationDetailsDto
     */
    'automaticStartup'?: boolean;
}
/**
 * 
 * @export
 * @interface ReservationDto
 */
export interface ReservationDto {
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'id'?: string;
    /**
     * 
     * @type {ResourceGroupDto}
     * @memberof ReservationDto
     */
    'resourceGroup'?: ResourceGroupDto;
    /**
     * 
     * @type {TeamDto}
     * @memberof ReservationDto
     */
    'team'?: TeamDto;
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface ResourceGroupDto
 */
export interface ResourceGroupDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupDto
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceGroupDto
     */
    'stateless'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceGroupNetworkDto
 */
export interface ResourceGroupNetworkDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupNetworkDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupNetworkDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ResourceGroupPoolDto
 */
export interface ResourceGroupPoolDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupPoolDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupPoolDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupPoolDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ResourcesAvailabilityDto
 */
export interface ResourcesAvailabilityDto {
    /**
     * 
     * @type {string}
     * @memberof ResourcesAvailabilityDto
     */
    'time'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourcesAvailabilityDto
     */
    'available'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourcesDto
 */
export interface ResourcesDto {
    /**
     * 
     * @type {number}
     * @memberof ResourcesDto
     */
    'cpuCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourcesDto
     */
    'memorySize'?: number;
}
/**
 * 
 * @export
 * @interface TeamAccessKeyDto
 */
export interface TeamAccessKeyDto {
    /**
     * 
     * @type {string}
     * @memberof TeamAccessKeyDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAccessKeyDto
     */
    'keyValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAccessKeyDto
     */
    'teamId'?: string;
}
/**
 * 
 * @export
 * @interface TeamDto
 */
export interface TeamDto {
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TeamDto
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TeamDto
     */
    'maxSize'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamDto
     */
    'users'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TeamWithCourseDto
 */
export interface TeamWithCourseDto {
    /**
     * 
     * @type {string}
     * @memberof TeamWithCourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamWithCourseDto
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TeamWithCourseDto
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TeamWithCourseDto
     */
    'maxSize'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamWithCourseDto
     */
    'users'?: Array<string>;
    /**
     * 
     * @type {CourseBasicDto}
     * @memberof TeamWithCourseDto
     */
    'course'?: CourseBasicDto;
}
/**
 * 
 * @export
 * @interface UpdateMetricValueDto
 */
export interface UpdateMetricValueDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface UpdateResourceGroupPoolDto
 */
export interface UpdateResourceGroupPoolDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceGroupPoolDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateResourceGroupPoolDto
     */
    'maxRent'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateResourceGroupPoolDto
     */
    'gracePeriod'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateResourceGroupPoolDto
     */
    'maxRentTime'?: number;
}
/**
 * 
 * @export
 * @interface UpdateTeamDto
 */
export interface UpdateTeamDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTeamDto
     */
    'maxSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTeamDto
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface ValueDto
 */
export interface ValueDto {
    /**
     * 
     * @type {number}
     * @memberof ValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface VlansRangeDto
 */
export interface VlansRangeDto {
    /**
     * 
     * @type {string}
     * @memberof VlansRangeDto
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VlansRangeDto
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof VlansRangeDto
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface VmDto
 */
export interface VmDto {
    /**
     * 
     * @type {string}
     * @memberof VmDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VmDto
     */
    'cpuCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmDto
     */
    'memory'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VmDto
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {Array<NicDto>}
     * @memberof VmDto
     */
    'nics'?: Array<NicDto>;
}
/**
 * 
 * @export
 * @interface VmGeneralDto
 */
export interface VmGeneralDto {
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'uptimeSeconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'cpuUsagePercentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'memoryUsagePercentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'networkUsagePercentage'?: string;
}
/**
 * 
 * @export
 * @interface VnicProfileDto
 */
export interface VnicProfileDto {
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'networkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'networkName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'networkVlanId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VnicProfileDto
     */
    'inPool'?: boolean;
}
/**
 * 
 * @export
 * @interface VnicProfilePoolMemberDto
 */
export interface VnicProfilePoolMemberDto {
    /**
     * 
     * @type {string}
     * @memberof VnicProfilePoolMemberDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfilePoolMemberDto
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VnicProfilePoolMemberDto
     */
    'inUse'?: boolean;
}

/**
 * AccessKeyControllerApi - axios parameter creator
 * @export
 */
export const AccessKeyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {string} courseKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseKey: async (courseId: string, courseKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createCourseKey', 'courseId', courseId)
            // verify required parameter 'courseKey' is not null or undefined
            assertParamExists('createCourseKey', 'courseKey', courseKey)
            const localVarPath = `/access-keys/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (courseKey !== undefined) {
                localVarQueryParameter['courseKey'] = courseKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyForCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getKeyForCourse', 'courseId', courseId)
            const localVarPath = `/access-keys/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyForTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getKeyForTeam', 'teamId', teamId)
            const localVarPath = `/access-keys/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} courseKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseKey: async (courseId: string, courseKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateCourseKey', 'courseId', courseId)
            // verify required parameter 'courseKey' is not null or undefined
            assertParamExists('updateCourseKey', 'courseKey', courseKey)
            const localVarPath = `/access-keys/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (courseKey !== undefined) {
                localVarQueryParameter['courseKey'] = courseKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessKeyControllerApi - functional programming interface
 * @export
 */
export const AccessKeyControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessKeyControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {string} courseKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseKey(courseId: string, courseKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseAccessKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseKey(courseId, courseKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeyControllerApi.createCourseKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeyForCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseAccessKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeyForCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeyControllerApi.getKeyForCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeyForTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAccessKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeyForTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeyControllerApi.getKeyForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} courseKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseKey(courseId: string, courseKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseAccessKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseKey(courseId, courseKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessKeyControllerApi.updateCourseKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessKeyControllerApi - factory interface
 * @export
 */
export const AccessKeyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessKeyControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {string} courseKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseKey(courseId: string, courseKey: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseAccessKeyDto> {
            return localVarFp.createCourseKey(courseId, courseKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyForCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseAccessKeyDto> {
            return localVarFp.getKeyForCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyForTeam(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<TeamAccessKeyDto> {
            return localVarFp.getKeyForTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} courseKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseKey(courseId: string, courseKey: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseAccessKeyDto> {
            return localVarFp.updateCourseKey(courseId, courseKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessKeyControllerApi - object-oriented interface
 * @export
 * @class AccessKeyControllerApi
 * @extends {BaseAPI}
 */
export class AccessKeyControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} courseId 
     * @param {string} courseKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeyControllerApi
     */
    public createCourseKey(courseId: string, courseKey: string, options?: RawAxiosRequestConfig) {
        return AccessKeyControllerApiFp(this.configuration).createCourseKey(courseId, courseKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeyControllerApi
     */
    public getKeyForCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return AccessKeyControllerApiFp(this.configuration).getKeyForCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeyControllerApi
     */
    public getKeyForTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return AccessKeyControllerApiFp(this.configuration).getKeyForTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} courseKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessKeyControllerApi
     */
    public updateCourseKey(courseId: string, courseKey: string, options?: RawAxiosRequestConfig) {
        return AccessKeyControllerApiFp(this.configuration).updateCourseKey(courseId, courseKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterControllerApi - axios parameter creator
 * @export
 */
export const ClusterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClusters: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findAllClusters', 'pageable', pageable)
            const localVarPath = `/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClusterById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findClusterById', 'id', id)
            const localVarPath = `/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsByClusterId: async (pageable: Pageable, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findEventsByClusterId', 'pageable', pageable)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findEventsByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHostInfoByClusterId: async (pageable: Pageable, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findHostInfoByClusterId', 'pageable', pageable)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findHostInfoByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/hosts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNetworksByClusterId: async (id: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findNetworksByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVirtualMachinesByClusterId: async (id: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findVirtualMachinesByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterControllerApi - functional programming interface
 * @export
 */
export const ClusterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllClusters(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClusterGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllClusters(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findAllClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClusterById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClusterById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findClusterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventsByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findEventsByClusterId(pageable, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findEventsByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findHostInfoByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HostDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findHostInfoByClusterId(pageable, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findHostInfoByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findNetworksByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findNetworksByClusterId(id, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findNetworksByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findVirtualMachinesByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findVirtualMachinesByClusterId(id, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findVirtualMachinesByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterControllerApi - factory interface
 * @export
 */
export const ClusterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClusters(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClusterGeneralDto>> {
            return localVarFp.findAllClusters(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClusterById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterDetailsDto> {
            return localVarFp.findClusterById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventGeneralDto>> {
            return localVarFp.findEventsByClusterId(pageable, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHostInfoByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<HostDto>> {
            return localVarFp.findHostInfoByClusterId(pageable, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNetworksByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<NetworkDto>> {
            return localVarFp.findNetworksByClusterId(id, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVirtualMachinesByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VmGeneralDto>> {
            return localVarFp.findVirtualMachinesByClusterId(id, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterControllerApi - object-oriented interface
 * @export
 * @class ClusterControllerApi
 * @extends {BaseAPI}
 */
export class ClusterControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findAllClusters(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findAllClusters(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findClusterById(id: string, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findClusterById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findEventsByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findEventsByClusterId(pageable, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findHostInfoByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findHostInfoByClusterId(pageable, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findNetworksByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findNetworksByClusterId(id, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findVirtualMachinesByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findVirtualMachinesByClusterId(id, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterMetricControllerApi - axios parameter creator
 * @export
 */
export const ClusterMetricControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricValue: async (clusterId: string, createMetricValueDto: CreateMetricValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createMetricValue', 'clusterId', clusterId)
            // verify required parameter 'createMetricValueDto' is not null or undefined
            assertParamExists('createMetricValue', 'createMetricValueDto', createMetricValueDto)
            const localVarPath = `/clusters/{clusterId}/metrics`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric1: async (clusterId: string, metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteMetric1', 'clusterId', clusterId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('deleteMetric1', 'metricId', metricId)
            const localVarPath = `/clusters/{clusterId}/metrics/{metricId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetricValues: async (clusterId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getAllMetricValues', 'clusterId', clusterId)
            const localVarPath = `/clusters/{clusterId}/metrics`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {ValueDto} valueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetricValue: async (clusterId: string, metricId: string, valueDto: ValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateMetricValue', 'clusterId', clusterId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('updateMetricValue', 'metricId', metricId)
            // verify required parameter 'valueDto' is not null or undefined
            assertParamExists('updateMetricValue', 'valueDto', valueDto)
            const localVarPath = `/clusters/{clusterId}/metrics/{metricId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterMetricControllerApi - functional programming interface
 * @export
 */
export const ClusterMetricControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterMetricControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricValue(clusterId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricValue(clusterId, createMetricValueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.createMetricValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric1(clusterId: string, metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric1(clusterId, metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.deleteMetric1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMetricValues(clusterId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoMetricValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMetricValues(clusterId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.getAllMetricValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {ValueDto} valueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetricValue(clusterId: string, metricId: string, valueDto: ValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetricValue(clusterId, metricId, valueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.updateMetricValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterMetricControllerApi - factory interface
 * @export
 */
export const ClusterMetricControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterMetricControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricValue(clusterId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createMetricValue(clusterId, createMetricValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric1(clusterId: string, metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMetric1(clusterId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetricValues(clusterId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoMetricValueDto> {
            return localVarFp.getAllMetricValues(clusterId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {ValueDto} valueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetricValue(clusterId: string, metricId: string, valueDto: ValueDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricValueDto> {
            return localVarFp.updateMetricValue(clusterId, metricId, valueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterMetricControllerApi - object-oriented interface
 * @export
 * @class ClusterMetricControllerApi
 * @extends {BaseAPI}
 */
export class ClusterMetricControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} clusterId 
     * @param {CreateMetricValueDto} createMetricValueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public createMetricValue(clusterId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).createMetricValue(clusterId, createMetricValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public deleteMetric1(clusterId: string, metricId: string, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).deleteMetric1(clusterId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public getAllMetricValues(clusterId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).getAllMetricValues(clusterId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {string} metricId 
     * @param {ValueDto} valueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public updateMetricValue(clusterId: string, metricId: string, valueDto: ValueDto, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).updateMetricValue(clusterId, metricId, valueDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseControllerApi - axios parameter creator
 * @export
 */
export const CourseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCourse: async (createCourseDto: CreateCourseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseDto' is not null or undefined
            assertParamExists('addCourse', 'createCourseDto', createCourseDto)
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroup: async (id: string, createResourceGroupDto: CreateResourceGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createResourceGroup', 'id', id)
            // verify required parameter 'createResourceGroupDto' is not null or undefined
            assertParamExists('createResourceGroup', 'createResourceGroupDto', createResourceGroupDto)
            const localVarPath = `/course/{id}/resource-group`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourse', 'id', id)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} rgId 
         * @param {number} window 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findResourcesAvailabilityForResourceGroup: async (id: string, rgId: string, window: number, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroup', 'id', id)
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroup', 'rgId', rgId)
            // verify required parameter 'window' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroup', 'window', window)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroup', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroup', 'end', end)
            const localVarPath = `/course/{id}/resource-groups/{rgId}/availability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} rgPoolId 
         * @param {number} window 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findResourcesAvailabilityForResourceGroupPool: async (id: string, rgPoolId: string, window: number, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroupPool', 'id', id)
            // verify required parameter 'rgPoolId' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroupPool', 'rgPoolId', rgPoolId)
            // verify required parameter 'window' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroupPool', 'window', window)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroupPool', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findResourcesAvailabilityForResourceGroupPool', 'end', end)
            const localVarPath = `/course/{id}/resource-group-pools/{rgPoolId}/availability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"rgPoolId"}}`, encodeURIComponent(String(rgPoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (window !== undefined) {
                localVarQueryParameter['window'] = window;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourse', 'id', id)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResourceGroupPools: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseResourceGroupPools', 'id', id)
            const localVarPath = `/course/{id}/resource-group-pools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStatefulResourceGroups: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseStatefulResourceGroups', 'id', id)
            const localVarPath = `/course/{id}/stateful`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoursesForStudent: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getCoursesForStudent', 'pageable', pageable)
            const localVarPath = `/course/member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse: async (id: string, createCourseDto: CreateCourseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourse', 'id', id)
            // verify required parameter 'createCourseDto' is not null or undefined
            assertParamExists('updateCourse', 'createCourseDto', createCourseDto)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseControllerApi - functional programming interface
 * @export
 */
export const CourseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCourse(createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCourse(createCourseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.addCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceGroup(id: string, createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceGroup(id, createResourceGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.createResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.deleteCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} rgId 
         * @param {number} window 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findResourcesAvailabilityForResourceGroup(id: string, rgId: string, window: number, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourcesAvailabilityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findResourcesAvailabilityForResourceGroup(id, rgId, window, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.findResourcesAvailabilityForResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} rgPoolId 
         * @param {number} window 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findResourcesAvailabilityForResourceGroupPool(id: string, rgPoolId: string, window: number, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourcesAvailabilityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findResourcesAvailabilityForResourceGroupPool(id, rgPoolId, window, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.findResourcesAvailabilityForResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseResourceGroupPools(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupPoolDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseResourceGroupPools(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourseResourceGroupPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseStatefulResourceGroups(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseStatefulResourceGroups(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourseStatefulResourceGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoursesForStudent(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoursesForStudent(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCoursesForStudent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourse(id: string, createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourse(id, createCourseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.updateCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseControllerApi - factory interface
 * @export
 */
export const CourseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCourse(createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig): AxiosPromise<CourseDto> {
            return localVarFp.addCourse(createCourseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroup(id: string, createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createResourceGroup(id, createResourceGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} rgId 
         * @param {number} window 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findResourcesAvailabilityForResourceGroup(id: string, rgId: string, window: number, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourcesAvailabilityDto>> {
            return localVarFp.findResourcesAvailabilityForResourceGroup(id, rgId, window, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} rgPoolId 
         * @param {number} window 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findResourcesAvailabilityForResourceGroupPool(id: string, rgPoolId: string, window: number, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourcesAvailabilityDto>> {
            return localVarFp.findResourcesAvailabilityForResourceGroupPool(id, rgPoolId, window, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseDto> {
            return localVarFp.getCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResourceGroupPools(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupPoolDto>> {
            return localVarFp.getCourseResourceGroupPools(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseStatefulResourceGroups(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupDto>> {
            return localVarFp.getCourseStatefulResourceGroups(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoCourseDto> {
            return localVarFp.getCourses(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoursesForStudent(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<Array<CourseDto>> {
            return localVarFp.getCoursesForStudent(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse(id: string, createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCourse(id, createCourseDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseControllerApi - object-oriented interface
 * @export
 * @class CourseControllerApi
 * @extends {BaseAPI}
 */
export class CourseControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCourseDto} createCourseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public addCourse(createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).addCourse(createCourseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CreateResourceGroupDto} createResourceGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public createResourceGroup(id: string, createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).createResourceGroup(id, createResourceGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public deleteCourse(id: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).deleteCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} rgId 
     * @param {number} window 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public findResourcesAvailabilityForResourceGroup(id: string, rgId: string, window: number, start: string, end: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).findResourcesAvailabilityForResourceGroup(id, rgId, window, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} rgPoolId 
     * @param {number} window 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public findResourcesAvailabilityForResourceGroupPool(id: string, rgPoolId: string, window: number, start: string, end: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).findResourcesAvailabilityForResourceGroupPool(id, rgPoolId, window, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourse(id: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourseResourceGroupPools(id: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourseResourceGroupPools(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourseStatefulResourceGroups(id: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourseStatefulResourceGroups(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourses(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourses(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCoursesForStudent(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCoursesForStudent(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CreateCourseDto} createCourseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public updateCourse(id: string, createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).updateCourse(id, createCourseDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseMetricControllerApi - axios parameter creator
 * @export
 */
export const CourseMetricControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric: async (courseId: string, createMetricValueDto: CreateMetricValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createMetric', 'courseId', courseId)
            // verify required parameter 'createMetricValueDto' is not null or undefined
            assertParamExists('createMetric', 'createMetricValueDto', createMetricValueDto)
            const localVarPath = `/course/{courseId}/metric`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric: async (courseId: string, metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteMetric', 'courseId', courseId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('deleteMetric', 'metricId', metricId)
            const localVarPath = `/course/{courseId}/metric/{metricId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (courseId: string, metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMetric', 'courseId', courseId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('getMetric', 'metricId', metricId)
            const localVarPath = `/course/{courseId}/metric/{metricId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMetrics', 'courseId', courseId)
            const localVarPath = `/course/{courseId}/metric`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {UpdateMetricValueDto} updateMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetric: async (courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateMetric', 'courseId', courseId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('updateMetric', 'metricId', metricId)
            // verify required parameter 'updateMetricValueDto' is not null or undefined
            assertParamExists('updateMetric', 'updateMetricValueDto', updateMetricValueDto)
            const localVarPath = `/course/{courseId}/metric/{metricId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseMetricControllerApi - functional programming interface
 * @export
 */
export const CourseMetricControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseMetricControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetric(courseId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetric(courseId, createMetricValueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.createMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric(courseId, metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.deleteMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(courseId, metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.getMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetricValueDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.getMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {UpdateMetricValueDto} updateMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetric(courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetric(courseId, metricId, updateMetricValueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.updateMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseMetricControllerApi - factory interface
 * @export
 */
export const CourseMetricControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseMetricControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric(courseId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createMetric(courseId, createMetricValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMetric(courseId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricValueDto> {
            return localVarFp.getMetric(courseId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MetricValueDto>> {
            return localVarFp.getMetrics(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {UpdateMetricValueDto} updateMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetric(courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMetric(courseId, metricId, updateMetricValueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseMetricControllerApi - object-oriented interface
 * @export
 * @class CourseMetricControllerApi
 * @extends {BaseAPI}
 */
export class CourseMetricControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} courseId 
     * @param {CreateMetricValueDto} createMetricValueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public createMetric(courseId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).createMetric(courseId, createMetricValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public deleteMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).deleteMetric(courseId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public getMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).getMetric(courseId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public getMetrics(courseId: string, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).getMetrics(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} metricId 
     * @param {UpdateMetricValueDto} updateMetricValueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public updateMetric(courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).updateMetric(courseId, metricId, updateMetricValueDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaintenanceIntervalControllerApi - axios parameter creator
 * @export
 */
export const MaintenanceIntervalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewClusterMaintenanceInterval: async (clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createNewClusterMaintenanceInterval', 'clusterId', clusterId)
            // verify required parameter 'createMaintenanceIntervalDto' is not null or undefined
            assertParamExists('createNewClusterMaintenanceInterval', 'createMaintenanceIntervalDto', createMaintenanceIntervalDto)
            const localVarPath = `/maintenance-intervals/cluster/{clusterId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaintenanceIntervalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSystemMaintenanceInterval: async (createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMaintenanceIntervalDto' is not null or undefined
            assertParamExists('createNewSystemMaintenanceInterval', 'createMaintenanceIntervalDto', createMaintenanceIntervalDto)
            const localVarPath = `/maintenance-intervals/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaintenanceIntervalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishMaintenanceInterval: async (intervalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'intervalId' is not null or undefined
            assertParamExists('finishMaintenanceInterval', 'intervalId', intervalId)
            const localVarPath = `/maintenance-intervals/{intervalId}`
                .replace(`{${"intervalId"}}`, encodeURIComponent(String(intervalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [clusterId] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaintenanceIntervals: async (pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/maintenance-intervals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['clusterId'] = clusterId;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceInterval: async (intervalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'intervalId' is not null or undefined
            assertParamExists('getMaintenanceInterval', 'intervalId', intervalId)
            const localVarPath = `/maintenance-intervals/{intervalId}`
                .replace(`{${"intervalId"}}`, encodeURIComponent(String(intervalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} start 
         * @param {string} end 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceIntervalsWithinTimePeriod: async (start: string, end: string, clusterId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getMaintenanceIntervalsWithinTimePeriod', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getMaintenanceIntervalsWithinTimePeriod', 'end', end)
            const localVarPath = `/maintenance-intervals/time-period`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clusterId !== undefined) {
                localVarQueryParameter['clusterId'] = clusterId;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintenanceIntervalControllerApi - functional programming interface
 * @export
 */
export const MaintenanceIntervalControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceIntervalControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewClusterMaintenanceInterval(clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewClusterMaintenanceInterval(clusterId, createMaintenanceIntervalDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.createNewClusterMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewSystemMaintenanceInterval(createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewSystemMaintenanceInterval(createMaintenanceIntervalDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.createNewSystemMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishMaintenanceInterval(intervalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.finishMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [clusterId] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMaintenanceIntervals(pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoMaintenanceIntervalDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMaintenanceIntervals(pageNumber, pageSize, clusterId, active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.getAllMaintenanceIntervals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceIntervalDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceInterval(intervalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.getMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} start 
         * @param {string} end 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceIntervalsWithinTimePeriod(start: string, end: string, clusterId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintenanceIntervalDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceIntervalsWithinTimePeriod(start, end, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.getMaintenanceIntervalsWithinTimePeriod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaintenanceIntervalControllerApi - factory interface
 * @export
 */
export const MaintenanceIntervalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintenanceIntervalControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewClusterMaintenanceInterval(clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewClusterMaintenanceInterval(clusterId, createMaintenanceIntervalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSystemMaintenanceInterval(createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewSystemMaintenanceInterval(createMaintenanceIntervalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.finishMaintenanceInterval(intervalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [clusterId] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaintenanceIntervals(pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoMaintenanceIntervalDto> {
            return localVarFp.getAllMaintenanceIntervals(pageNumber, pageSize, clusterId, active, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceIntervalDetailsDto> {
            return localVarFp.getMaintenanceInterval(intervalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} start 
         * @param {string} end 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceIntervalsWithinTimePeriod(start: string, end: string, clusterId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MaintenanceIntervalDto>> {
            return localVarFp.getMaintenanceIntervalsWithinTimePeriod(start, end, clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaintenanceIntervalControllerApi - object-oriented interface
 * @export
 * @class MaintenanceIntervalControllerApi
 * @extends {BaseAPI}
 */
export class MaintenanceIntervalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} clusterId 
     * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public createNewClusterMaintenanceInterval(clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).createNewClusterMaintenanceInterval(clusterId, createMaintenanceIntervalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public createNewSystemMaintenanceInterval(createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).createNewSystemMaintenanceInterval(createMaintenanceIntervalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} intervalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public finishMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).finishMaintenanceInterval(intervalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {string} [clusterId] 
     * @param {boolean} [active] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public getAllMaintenanceIntervals(pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).getAllMaintenanceIntervals(pageNumber, pageSize, clusterId, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} intervalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public getMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).getMaintenanceInterval(intervalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} start 
     * @param {string} end 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public getMaintenanceIntervalsWithinTimePeriod(start: string, end: string, clusterId?: string, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).getMaintenanceIntervalsWithinTimePeriod(start, end, clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricControllerApi - axios parameter creator
 * @export
 */
export const MetricControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMetricDto} createMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMetric: async (createMetricDto: CreateMetricDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMetricDto' is not null or undefined
            assertParamExists('createNewMetric', 'createMetricDto', createMetricDto)
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric2: async (metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('deleteMetric2', 'metricId', metricId)
            const localVarPath = `/metrics/{metricId}`
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetrics: async (pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricControllerApi - functional programming interface
 * @export
 */
export const MetricControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateMetricDto} createMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewMetric(createMetricDto: CreateMetricDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewMetric(createMetricDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricControllerApi.createNewMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric2(metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric2(metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricControllerApi.deleteMetric2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMetrics(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMetrics(pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricControllerApi.getAllMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricControllerApi - factory interface
 * @export
 */
export const MetricControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateMetricDto} createMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMetric(createMetricDto: CreateMetricDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewMetric(createMetricDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric2(metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMetric2(metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetrics(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoMetricDto> {
            return localVarFp.getAllMetrics(pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricControllerApi - object-oriented interface
 * @export
 * @class MetricControllerApi
 * @extends {BaseAPI}
 */
export class MetricControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateMetricDto} createMetricDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricControllerApi
     */
    public createNewMetric(createMetricDto: CreateMetricDto, options?: RawAxiosRequestConfig) {
        return MetricControllerApiFp(this.configuration).createNewMetric(createMetricDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricControllerApi
     */
    public deleteMetric2(metricId: string, options?: RawAxiosRequestConfig) {
        return MetricControllerApiFp(this.configuration).deleteMetric2(metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricControllerApi
     */
    public getAllMetrics(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return MetricControllerApiFp(this.configuration).getAllMetrics(pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OVirtUserControllerApi - axios parameter creator
 * @export
 */
export const OVirtUserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersWithPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/resources/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OVirtUserControllerApi - functional programming interface
 * @export
 */
export const OVirtUserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OVirtUserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OVirtUserControllerApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersWithPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersWithPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OVirtUserControllerApi.getAllUsersWithPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OVirtUserControllerApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OVirtUserControllerApi - factory interface
 * @export
 */
export const OVirtUserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OVirtUserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersWithPermissions(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllUsersWithPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OVirtUserControllerApi - object-oriented interface
 * @export
 * @class OVirtUserControllerApi
 * @extends {BaseAPI}
 */
export class OVirtUserControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OVirtUserControllerApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return OVirtUserControllerApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OVirtUserControllerApi
     */
    public getAllUsersWithPermissions(options?: RawAxiosRequestConfig) {
        return OVirtUserControllerApiFp(this.configuration).getAllUsersWithPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OVirtUserControllerApi
     */
    public getUserById(userId: string, options?: RawAxiosRequestConfig) {
        return OVirtUserControllerApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionControllerApi - axios parameter creator
 * @export
 */
export const PermissionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} vmId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermissionToVmToUser: async (vmId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('assignPermissionToVmToUser', 'vmId', vmId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignPermissionToVmToUser', 'userId', userId)
            const localVarPath = `/resources/permissions/vm/{vmId}/user/{userId}`
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findPermissionByUserId', 'userId', userId)
            const localVarPath = `/resources/permissions/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByVmId: async (vmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('findPermissionByVmId', 'vmId', vmId)
            const localVarPath = `/resources/permissions/vm/{vmId}`
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionToVmFromUser: async (permissionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('revokePermissionToVmFromUser', 'permissionId', permissionId)
            const localVarPath = `/resources/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionControllerApi - functional programming interface
 * @export
 */
export const PermissionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} vmId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignPermissionToVmToUser(vmId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionToVmToUser(vmId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionControllerApi.assignPermissionToVmToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPermissionByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPermissionByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionControllerApi.findPermissionByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPermissionByVmId(vmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPermissionByVmId(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionControllerApi.findPermissionByVmId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokePermissionToVmFromUser(permissionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokePermissionToVmFromUser(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionControllerApi.revokePermissionToVmFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionControllerApi - factory interface
 * @export
 */
export const PermissionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} vmId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermissionToVmToUser(vmId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignPermissionToVmToUser(vmId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByUserId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.findPermissionByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByVmId(vmId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.findPermissionByVmId(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionToVmFromUser(permissionId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.revokePermissionToVmFromUser(permissionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionControllerApi - object-oriented interface
 * @export
 * @class PermissionControllerApi
 * @extends {BaseAPI}
 */
export class PermissionControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} vmId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionControllerApi
     */
    public assignPermissionToVmToUser(vmId: string, userId: string, options?: RawAxiosRequestConfig) {
        return PermissionControllerApiFp(this.configuration).assignPermissionToVmToUser(vmId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionControllerApi
     */
    public findPermissionByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return PermissionControllerApiFp(this.configuration).findPermissionByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionControllerApi
     */
    public findPermissionByVmId(vmId: string, options?: RawAxiosRequestConfig) {
        return PermissionControllerApiFp(this.configuration).findPermissionByVmId(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionControllerApi
     */
    public revokePermissionToVmFromUser(permissionId: string, options?: RawAxiosRequestConfig) {
        return PermissionControllerApiFp(this.configuration).revokePermissionToVmFromUser(permissionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PodStatefulControllerApi - axios parameter creator
 * @export
 */
export const PodStatefulControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new stateful pod for the specified team and resource group
         * @summary Create new stateful pod
         * @param {CreatePodStatefulDto} createPodStatefulDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStatefulPod: async (createPodStatefulDto: CreatePodStatefulDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPodStatefulDto' is not null or undefined
            assertParamExists('createStatefulPod', 'createPodStatefulDto', createPodStatefulDto)
            const localVarPath = `/pods/stateful`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPodStatefulDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific stateful pod
         * @summary Delete pod
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStatefulPod: async (podId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('deleteStatefulPod', 'podId', podId)
            const localVarPath = `/pods/stateful/{podId}`
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific stateful pod
         * @summary Get pod details
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPod: async (podId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('getStatefulPod', 'podId', podId)
            const localVarPath = `/pods/stateful/{podId}`
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stateful pods for a specific course
         * @summary Get course pods
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPodsByCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getStatefulPodsByCourse', 'courseId', courseId)
            const localVarPath = `/pods/stateful/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stateful pods for a specific resource group
         * @summary Get resource group pods
         * @param {string} resourceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPodsByResourceGroup: async (resourceGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceGroupId' is not null or undefined
            assertParamExists('getStatefulPodsByResourceGroup', 'resourceGroupId', resourceGroupId)
            const localVarPath = `/pods/stateful/resource-group/{resourceGroupId}`
                .replace(`{${"resourceGroupId"}}`, encodeURIComponent(String(resourceGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stateful pods for a specific team
         * @summary Get team pods
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPodsByTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getStatefulPodsByTeam', 'teamId', teamId)
            const localVarPath = `/pods/stateful/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodStatefulControllerApi - functional programming interface
 * @export
 */
export const PodStatefulControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PodStatefulControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new stateful pod for the specified team and resource group
         * @summary Create new stateful pod
         * @param {CreatePodStatefulDto} createPodStatefulDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStatefulPod(createPodStatefulDto: CreatePodStatefulDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodStatefulDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStatefulPod(createPodStatefulDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.createStatefulPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific stateful pod
         * @summary Delete pod
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStatefulPod(podId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStatefulPod(podId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.deleteStatefulPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific stateful pod
         * @summary Get pod details
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatefulPod(podId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodStatefulDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatefulPod(podId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getStatefulPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stateful pods for a specific course
         * @summary Get course pods
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatefulPodsByCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatefulDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatefulPodsByCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getStatefulPodsByCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stateful pods for a specific resource group
         * @summary Get resource group pods
         * @param {string} resourceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatefulPodsByResourceGroup(resourceGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatefulDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatefulPodsByResourceGroup(resourceGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getStatefulPodsByResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stateful pods for a specific team
         * @summary Get team pods
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatefulPodsByTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatefulDetailsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatefulPodsByTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getStatefulPodsByTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PodStatefulControllerApi - factory interface
 * @export
 */
export const PodStatefulControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PodStatefulControllerApiFp(configuration)
    return {
        /**
         * Creates a new stateful pod for the specified team and resource group
         * @summary Create new stateful pod
         * @param {CreatePodStatefulDto} createPodStatefulDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStatefulPod(createPodStatefulDto: CreatePodStatefulDto, options?: RawAxiosRequestConfig): AxiosPromise<PodStatefulDto> {
            return localVarFp.createStatefulPod(createPodStatefulDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific stateful pod
         * @summary Delete pod
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStatefulPod(podId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteStatefulPod(podId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific stateful pod
         * @summary Get pod details
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPod(podId: string, options?: RawAxiosRequestConfig): AxiosPromise<PodStatefulDetailsDto> {
            return localVarFp.getStatefulPod(podId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stateful pods for a specific course
         * @summary Get course pods
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPodsByCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatefulDto>> {
            return localVarFp.getStatefulPodsByCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stateful pods for a specific resource group
         * @summary Get resource group pods
         * @param {string} resourceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPodsByResourceGroup(resourceGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatefulDto>> {
            return localVarFp.getStatefulPodsByResourceGroup(resourceGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stateful pods for a specific team
         * @summary Get team pods
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatefulPodsByTeam(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatefulDetailsDto>> {
            return localVarFp.getStatefulPodsByTeam(teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PodStatefulControllerApi - object-oriented interface
 * @export
 * @class PodStatefulControllerApi
 * @extends {BaseAPI}
 */
export class PodStatefulControllerApi extends BaseAPI {
    /**
     * Creates a new stateful pod for the specified team and resource group
     * @summary Create new stateful pod
     * @param {CreatePodStatefulDto} createPodStatefulDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public createStatefulPod(createPodStatefulDto: CreatePodStatefulDto, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).createStatefulPod(createPodStatefulDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific stateful pod
     * @summary Delete pod
     * @param {string} podId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public deleteStatefulPod(podId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).deleteStatefulPod(podId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific stateful pod
     * @summary Get pod details
     * @param {string} podId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getStatefulPod(podId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getStatefulPod(podId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stateful pods for a specific course
     * @summary Get course pods
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getStatefulPodsByCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getStatefulPodsByCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stateful pods for a specific resource group
     * @summary Get resource group pods
     * @param {string} resourceGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getStatefulPodsByResourceGroup(resourceGroupId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getStatefulPodsByResourceGroup(resourceGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stateful pods for a specific team
     * @summary Get team pods
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getStatefulPodsByTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getStatefulPodsByTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PodStatelessControllerApi - axios parameter creator
 * @export
 */
export const PodStatelessControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new stateless pod for the specified team and resource group pool
         * @summary Create new stateless pod
         * @param {CreatePodStatelessDto} createPodStatelessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStatelessPod: async (createPodStatelessDto: CreatePodStatelessDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPodStatelessDto' is not null or undefined
            assertParamExists('createStatelessPod', 'createPodStatelessDto', createPodStatelessDto)
            const localVarPath = `/pods/stateless`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPodStatelessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific stateless pod
         * @summary Delete pod
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStatelessPod: async (podId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('deleteStatelessPod', 'podId', podId)
            const localVarPath = `/pods/stateless/{podId}`
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific stateless pod
         * @summary Get pod details
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPod: async (podId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('getStatelessPod', 'podId', podId)
            const localVarPath = `/pods/stateless/{podId}`
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stateless pods for a specific course
         * @summary Get course pods
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPodsByCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getStatelessPodsByCourse', 'courseId', courseId)
            const localVarPath = `/pods/stateless/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stateless pods for a specific resource group pool
         * @summary Get resource group pool pods
         * @param {string} poolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPodsByResourceGroupPool: async (poolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('getStatelessPodsByResourceGroupPool', 'poolId', poolId)
            const localVarPath = `/pods/stateless/resource-group-pool/{poolId}`
                .replace(`{${"poolId"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stateless pods for a specific team
         * @summary Get team pods
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPodsByTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getStatelessPodsByTeam', 'teamId', teamId)
            const localVarPath = `/pods/stateless/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodStatelessControllerApi - functional programming interface
 * @export
 */
export const PodStatelessControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PodStatelessControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new stateless pod for the specified team and resource group pool
         * @summary Create new stateless pod
         * @param {CreatePodStatelessDto} createPodStatelessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStatelessPod(createPodStatelessDto: CreatePodStatelessDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodStatelessDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStatelessPod(createPodStatelessDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatelessControllerApi.createStatelessPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific stateless pod
         * @summary Delete pod
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStatelessPod(podId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStatelessPod(podId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatelessControllerApi.deleteStatelessPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific stateless pod
         * @summary Get pod details
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatelessPod(podId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodStatelessDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatelessPod(podId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatelessControllerApi.getStatelessPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stateless pods for a specific course
         * @summary Get course pods
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatelessPodsByCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatelessDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatelessPodsByCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatelessControllerApi.getStatelessPodsByCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stateless pods for a specific resource group pool
         * @summary Get resource group pool pods
         * @param {string} poolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatelessPodsByResourceGroupPool(poolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatelessDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatelessPodsByResourceGroupPool(poolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatelessControllerApi.getStatelessPodsByResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stateless pods for a specific team
         * @summary Get team pods
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatelessPodsByTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatelessDetailsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatelessPodsByTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatelessControllerApi.getStatelessPodsByTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PodStatelessControllerApi - factory interface
 * @export
 */
export const PodStatelessControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PodStatelessControllerApiFp(configuration)
    return {
        /**
         * Creates a new stateless pod for the specified team and resource group pool
         * @summary Create new stateless pod
         * @param {CreatePodStatelessDto} createPodStatelessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStatelessPod(createPodStatelessDto: CreatePodStatelessDto, options?: RawAxiosRequestConfig): AxiosPromise<PodStatelessDto> {
            return localVarFp.createStatelessPod(createPodStatelessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific stateless pod
         * @summary Delete pod
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStatelessPod(podId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteStatelessPod(podId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific stateless pod
         * @summary Get pod details
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPod(podId: string, options?: RawAxiosRequestConfig): AxiosPromise<PodStatelessDetailsDto> {
            return localVarFp.getStatelessPod(podId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stateless pods for a specific course
         * @summary Get course pods
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPodsByCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatelessDto>> {
            return localVarFp.getStatelessPodsByCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stateless pods for a specific resource group pool
         * @summary Get resource group pool pods
         * @param {string} poolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPodsByResourceGroupPool(poolId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatelessDto>> {
            return localVarFp.getStatelessPodsByResourceGroupPool(poolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stateless pods for a specific team
         * @summary Get team pods
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatelessPodsByTeam(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatelessDetailsDto>> {
            return localVarFp.getStatelessPodsByTeam(teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PodStatelessControllerApi - object-oriented interface
 * @export
 * @class PodStatelessControllerApi
 * @extends {BaseAPI}
 */
export class PodStatelessControllerApi extends BaseAPI {
    /**
     * Creates a new stateless pod for the specified team and resource group pool
     * @summary Create new stateless pod
     * @param {CreatePodStatelessDto} createPodStatelessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatelessControllerApi
     */
    public createStatelessPod(createPodStatelessDto: CreatePodStatelessDto, options?: RawAxiosRequestConfig) {
        return PodStatelessControllerApiFp(this.configuration).createStatelessPod(createPodStatelessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific stateless pod
     * @summary Delete pod
     * @param {string} podId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatelessControllerApi
     */
    public deleteStatelessPod(podId: string, options?: RawAxiosRequestConfig) {
        return PodStatelessControllerApiFp(this.configuration).deleteStatelessPod(podId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific stateless pod
     * @summary Get pod details
     * @param {string} podId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatelessControllerApi
     */
    public getStatelessPod(podId: string, options?: RawAxiosRequestConfig) {
        return PodStatelessControllerApiFp(this.configuration).getStatelessPod(podId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stateless pods for a specific course
     * @summary Get course pods
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatelessControllerApi
     */
    public getStatelessPodsByCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return PodStatelessControllerApiFp(this.configuration).getStatelessPodsByCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stateless pods for a specific resource group pool
     * @summary Get resource group pool pods
     * @param {string} poolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatelessControllerApi
     */
    public getStatelessPodsByResourceGroupPool(poolId: string, options?: RawAxiosRequestConfig) {
        return PodStatelessControllerApiFp(this.configuration).getStatelessPodsByResourceGroupPool(poolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stateless pods for a specific team
     * @summary Get team pods
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatelessControllerApi
     */
    public getStatelessPodsByTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return PodStatelessControllerApiFp(this.configuration).getStatelessPodsByTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PrivateNetworkControllerApi - axios parameter creator
 * @export
 */
export const PrivateNetworkControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachNicToNetwork: async (id: string, networkVmConnectionDto: NetworkVmConnectionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attachNicToNetwork', 'id', id)
            // verify required parameter 'networkVmConnectionDto' is not null or undefined
            assertParamExists('attachNicToNetwork', 'networkVmConnectionDto', networkVmConnectionDto)
            const localVarPath = `/network/{id}/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkVmConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNetwork', 'id', id)
            const localVarPath = `/network/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachNicFromNetwork: async (networkVmConnectionDto: NetworkVmConnectionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkVmConnectionDto' is not null or undefined
            assertParamExists('detachNicFromNetwork', 'networkVmConnectionDto', networkVmConnectionDto)
            const localVarPath = `/network/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkVmConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrivateNetworkControllerApi - functional programming interface
 * @export
 */
export const PrivateNetworkControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrivateNetworkControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachNicToNetwork(id: string, networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachNicToNetwork(id, networkVmConnectionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrivateNetworkControllerApi.attachNicToNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetwork(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetwork(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrivateNetworkControllerApi.deleteNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachNicFromNetwork(networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachNicFromNetwork(networkVmConnectionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrivateNetworkControllerApi.detachNicFromNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PrivateNetworkControllerApi - factory interface
 * @export
 */
export const PrivateNetworkControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrivateNetworkControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachNicToNetwork(id: string, networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.attachNicToNetwork(id, networkVmConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNetwork(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachNicFromNetwork(networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.detachNicFromNetwork(networkVmConnectionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrivateNetworkControllerApi - object-oriented interface
 * @export
 * @class PrivateNetworkControllerApi
 * @extends {BaseAPI}
 */
export class PrivateNetworkControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {NetworkVmConnectionDto} networkVmConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrivateNetworkControllerApi
     */
    public attachNicToNetwork(id: string, networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig) {
        return PrivateNetworkControllerApiFp(this.configuration).attachNicToNetwork(id, networkVmConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrivateNetworkControllerApi
     */
    public deleteNetwork(id: string, options?: RawAxiosRequestConfig) {
        return PrivateNetworkControllerApiFp(this.configuration).deleteNetwork(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NetworkVmConnectionDto} networkVmConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrivateNetworkControllerApi
     */
    public detachNicFromNetwork(networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig) {
        return PrivateNetworkControllerApiFp(this.configuration).detachNicFromNetwork(networkVmConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReservationControllerApi - axios parameter creator
 * @export
 */
export const ReservationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to create a new reservation for the team they are a part of.
         * @summary Create new reservation
         * @param {string} courseId 
         * @param {string} podId 
         * @param {CreateReservationDto} createReservationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReservationForPod: async (courseId: string, podId: string, createReservationDto: CreateReservationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createNewReservationForPod', 'courseId', courseId)
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('createNewReservationForPod', 'podId', podId)
            // verify required parameter 'createReservationDto' is not null or undefined
            assertParamExists('createNewReservationForPod', 'createReservationDto', createReservationDto)
            const localVarPath = `/reservations/course/{courseId}/pod/{podId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReservationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishReservation: async (reservationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('finishReservation', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}/cancel`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservations: async (courseId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getActiveReservations', 'courseId', courseId)
            const localVarPath = `/reservations/active/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservationsForTeam: async (teamId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getActiveReservationsForTeam', 'teamId', teamId)
            const localVarPath = `/reservations/active/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservations: async (courseId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getHistoricReservations', 'courseId', courseId)
            const localVarPath = `/reservations/historic/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservationsForTeam: async (teamId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getHistoricReservationsForTeam', 'teamId', teamId)
            const localVarPath = `/reservations/historic/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} courseId 
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousReservations: async (pageable: Pageable, courseId: string, podId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getPreviousReservations', 'pageable', pageable)
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getPreviousReservations', 'courseId', courseId)
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('getPreviousReservations', 'podId', podId)
            const localVarPath = `/reservations/course/{courseId}/pods/{podId}/previous`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservationDetails: async (reservationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('getReservationDetails', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} rgPoolId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRgPoolReservationsInGivenCourse: async (courseId: string, rgPoolId: string, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getRgPoolReservationsInGivenCourse', 'courseId', courseId)
            // verify required parameter 'rgPoolId' is not null or undefined
            assertParamExists('getRgPoolReservationsInGivenCourse', 'rgPoolId', rgPoolId)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getRgPoolReservationsInGivenCourse', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getRgPoolReservationsInGivenCourse', 'end', end)
            const localVarPath = `/reservations/courses/{courseId}/resource-group-pools/{rgPoolId}/period`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"rgPoolId"}}`, encodeURIComponent(String(rgPoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} rgId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRgReservationsInGivenCourse: async (courseId: string, rgId: string, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getRgReservationsInGivenCourse', 'courseId', courseId)
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getRgReservationsInGivenCourse', 'rgId', rgId)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getRgReservationsInGivenCourse', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getRgReservationsInGivenCourse', 'end', end)
            const localVarPath = `/reservations/courses/{courseId}/resource-groups/{rgId}/period`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationControllerApi - functional programming interface
 * @export
 */
export const ReservationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint can be used to create a new reservation for the team they are a part of.
         * @summary Create new reservation
         * @param {string} courseId 
         * @param {string} podId 
         * @param {CreateReservationDto} createReservationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewReservationForPod(courseId: string, podId: string, createReservationDto: CreateReservationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewReservationForPod(courseId, podId, createReservationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.createNewReservationForPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishReservation(reservationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishReservation(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.finishReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveReservations(courseId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getActiveReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveReservationsForTeam(teamId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getActiveReservationsForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricReservations(courseId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getHistoricReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricReservationsForTeam(teamId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getHistoricReservationsForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} courseId 
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousReservations(pageable: Pageable, courseId: string, podId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousReservations(pageable, courseId, podId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getPreviousReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReservationDetails(reservationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReservationDetails(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getReservationDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} rgPoolId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRgPoolReservationsInGivenCourse(courseId: string, rgPoolId: string, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReservationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRgPoolReservationsInGivenCourse(courseId, rgPoolId, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getRgPoolReservationsInGivenCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} rgId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRgReservationsInGivenCourse(courseId: string, rgId: string, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReservationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRgReservationsInGivenCourse(courseId, rgId, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getRgReservationsInGivenCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReservationControllerApi - factory interface
 * @export
 */
export const ReservationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationControllerApiFp(configuration)
    return {
        /**
         * This endpoint can be used to create a new reservation for the team they are a part of.
         * @summary Create new reservation
         * @param {string} courseId 
         * @param {string} podId 
         * @param {CreateReservationDto} createReservationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReservationForPod(courseId: string, podId: string, createReservationDto: CreateReservationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewReservationForPod(courseId, podId, createReservationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishReservation(reservationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.finishReservation(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getActiveReservations(courseId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getActiveReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getHistoricReservations(courseId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getHistoricReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} courseId 
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousReservations(pageable: Pageable, courseId: string, podId: string, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getPreviousReservations(pageable, courseId, podId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservationDetails(reservationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReservationDetailsDto> {
            return localVarFp.getReservationDetails(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} rgPoolId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRgPoolReservationsInGivenCourse(courseId: string, rgPoolId: string, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReservationDto>> {
            return localVarFp.getRgPoolReservationsInGivenCourse(courseId, rgPoolId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} rgId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRgReservationsInGivenCourse(courseId: string, rgId: string, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReservationDto>> {
            return localVarFp.getRgReservationsInGivenCourse(courseId, rgId, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReservationControllerApi - object-oriented interface
 * @export
 * @class ReservationControllerApi
 * @extends {BaseAPI}
 */
export class ReservationControllerApi extends BaseAPI {
    /**
     * This endpoint can be used to create a new reservation for the team they are a part of.
     * @summary Create new reservation
     * @param {string} courseId 
     * @param {string} podId 
     * @param {CreateReservationDto} createReservationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public createNewReservationForPod(courseId: string, podId: string, createReservationDto: CreateReservationDto, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).createNewReservationForPod(courseId, podId, createReservationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public finishReservation(reservationId: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).finishReservation(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getActiveReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getActiveReservations(courseId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getActiveReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getActiveReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getHistoricReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getHistoricReservations(courseId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getHistoricReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getHistoricReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} courseId 
     * @param {string} podId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getPreviousReservations(pageable: Pageable, courseId: string, podId: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getPreviousReservations(pageable, courseId, podId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getReservationDetails(reservationId: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getReservationDetails(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} rgPoolId 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getRgPoolReservationsInGivenCourse(courseId: string, rgPoolId: string, start: string, end: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getRgPoolReservationsInGivenCourse(courseId, rgPoolId, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} rgId 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getRgReservationsInGivenCourse(courseId: string, rgId: string, start: string, end: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getRgReservationsInGivenCourse(courseId, rgId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedStatefulResourceGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-group/assigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResourceGroup', 'id', id)
            const localVarPath = `/resource-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedStatefulResourceGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedStatefulResourceGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupControllerApi.getAssignedStatefulResourceGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupControllerApi.getResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupControllerApi.getResourceGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupControllerApi - factory interface
 * @export
 */
export const ResourceGroupControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedStatefulResourceGroups(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupDto>> {
            return localVarFp.getAssignedStatefulResourceGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupDto> {
            return localVarFp.getResourceGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupDto>> {
            return localVarFp.getResourceGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupControllerApi
     */
    public getAssignedStatefulResourceGroups(options?: RawAxiosRequestConfig) {
        return ResourceGroupControllerApiFp(this.configuration).getAssignedStatefulResourceGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupControllerApi
     */
    public getResourceGroup(id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupControllerApiFp(this.configuration).getResourceGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupControllerApi
     */
    public getResourceGroups(options?: RawAxiosRequestConfig) {
        return ResourceGroupControllerApiFp(this.configuration).getResourceGroups(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupNetworkControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupNetworkControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResourceGroupNetwork: async (resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceGroupNetworkDto' is not null or undefined
            assertParamExists('addResourceGroupNetwork', 'resourceGroupNetworkDto', resourceGroupNetworkDto)
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('addResourceGroupNetwork', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/network`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resourceGroupNetworkDto !== undefined) {
                for (const [key, value] of Object.entries(resourceGroupNetworkDto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('get', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/network`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupNetworkControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupNetworkControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupNetworkControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResourceGroupNetwork(resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupNetworkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addResourceGroupNetwork(resourceGroupNetworkDto, rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupNetworkControllerApi.addResourceGroupNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupNetworkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupNetworkControllerApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupNetworkControllerApi - factory interface
 * @export
 */
export const ResourceGroupNetworkControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupNetworkControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResourceGroupNetwork(resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupNetworkDto> {
            return localVarFp.addResourceGroupNetwork(resourceGroupNetworkDto, rgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupNetworkDto>> {
            return localVarFp.get(rgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupNetworkControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupNetworkControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupNetworkControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupNetworkControllerApi
     */
    public addResourceGroupNetwork(resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupNetworkControllerApiFp(this.configuration).addResourceGroupNetwork(resourceGroupNetworkDto, rgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupNetworkControllerApi
     */
    public get(rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupNetworkControllerApiFp(this.configuration).get(rgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupPoolControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupPoolControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResourceGroupToPool: async (id: string, createResourceGroupDto: CreateResourceGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addResourceGroupToPool', 'id', id)
            // verify required parameter 'createResourceGroupDto' is not null or undefined
            assertParamExists('addResourceGroupToPool', 'createResourceGroupDto', createResourceGroupDto)
            const localVarPath = `/resource-group-pool/{id}/resourceGroup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateRGPoolDto} createRGPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroupPool: async (createRGPoolDto: CreateRGPoolDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRGPoolDto' is not null or undefined
            assertParamExists('createResourceGroupPool', 'createRGPoolDto', createRGPoolDto)
            const localVarPath = `/resource-group-pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRGPoolDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceGroupPool: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteResourceGroupPool', 'id', id)
            const localVarPath = `/resource-group-pool/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPool: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResourceGroupPool', 'id', id)
            const localVarPath = `/resource-group-pool/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPools: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-group-pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateResourceGroupPoolDto} updateResourceGroupPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceGroupPool: async (id: string, updateResourceGroupPoolDto: UpdateResourceGroupPoolDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateResourceGroupPool', 'id', id)
            // verify required parameter 'updateResourceGroupPoolDto' is not null or undefined
            assertParamExists('updateResourceGroupPool', 'updateResourceGroupPoolDto', updateResourceGroupPoolDto)
            const localVarPath = `/resource-group-pool/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceGroupPoolDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupPoolControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupPoolControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupPoolControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResourceGroupToPool(id: string, createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addResourceGroupToPool(id, createResourceGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.addResourceGroupToPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateRGPoolDto} createRGPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceGroupPool(createRGPoolDto: CreateRGPoolDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupPoolDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceGroupPool(createRGPoolDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.createResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceGroupPool(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceGroupPool(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.deleteResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroupPool(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedResourceGroupPoolDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroupPool(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.getResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroupPools(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoDetailedResourceGroupPoolDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroupPools(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.getResourceGroupPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateResourceGroupPoolDto} updateResourceGroupPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceGroupPool(id: string, updateResourceGroupPoolDto: UpdateResourceGroupPoolDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupPoolDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceGroupPool(id, updateResourceGroupPoolDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.updateResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupPoolControllerApi - factory interface
 * @export
 */
export const ResourceGroupPoolControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupPoolControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResourceGroupToPool(id: string, createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addResourceGroupToPool(id, createResourceGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateRGPoolDto} createRGPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroupPool(createRGPoolDto: CreateRGPoolDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupPoolDto> {
            return localVarFp.createResourceGroupPool(createRGPoolDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceGroupPool(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceGroupPool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPool(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedResourceGroupPoolDto> {
            return localVarFp.getResourceGroupPool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPools(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoDetailedResourceGroupPoolDto> {
            return localVarFp.getResourceGroupPools(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateResourceGroupPoolDto} updateResourceGroupPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceGroupPool(id: string, updateResourceGroupPoolDto: UpdateResourceGroupPoolDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupPoolDto> {
            return localVarFp.updateResourceGroupPool(id, updateResourceGroupPoolDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupPoolControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupPoolControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupPoolControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {CreateResourceGroupDto} createResourceGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public addResourceGroupToPool(id: string, createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).addResourceGroupToPool(id, createResourceGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateRGPoolDto} createRGPoolDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public createResourceGroupPool(createRGPoolDto: CreateRGPoolDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).createResourceGroupPool(createRGPoolDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public deleteResourceGroupPool(id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).deleteResourceGroupPool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public getResourceGroupPool(id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).getResourceGroupPool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public getResourceGroupPools(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).getResourceGroupPools(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateResourceGroupPoolDto} updateResourceGroupPoolDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public updateResourceGroupPool(id: string, updateResourceGroupPoolDto: UpdateResourceGroupPoolDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).updateResourceGroupPool(id, updateResourceGroupPoolDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupVmControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupVmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} rgId 
         * @param {AddVmDto} addVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVm: async (rgId: string, addVmDto: AddVmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('addVm', 'rgId', rgId)
            // verify required parameter 'addVmDto' is not null or undefined
            assertParamExists('addVm', 'addVmDto', addVmDto)
            const localVarPath = `/resource-group/{rgId}/vm`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVm: async (rgId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('deleteVm', 'rgId', rgId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVm', 'id', id)
            const localVarPath = `/resource-group/{rgId}/vm/{id}`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableVms: async (rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getAvailableVms', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/vm/available`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm: async (rgId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getVm', 'rgId', rgId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVm', 'id', id)
            const localVarPath = `/resource-group/{rgId}/vm/{id}`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms: async (rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getVms', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/vm`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {EditVmDto} editVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVm: async (rgId: string, id: string, editVmDto: EditVmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('updateVm', 'rgId', rgId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVm', 'id', id)
            // verify required parameter 'editVmDto' is not null or undefined
            assertParamExists('updateVm', 'editVmDto', editVmDto)
            const localVarPath = `/resource-group/{rgId}/vm/{id}`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editVmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupVmControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupVmControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupVmControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} rgId 
         * @param {AddVmDto} addVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVm(rgId: string, addVmDto: AddVmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVm(rgId, addVmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.addVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVm(rgId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVm(rgId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.deleteVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableVms(rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableVms(rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.getAvailableVms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVm(rgId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVm(rgId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.getVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVms(rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVms(rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.getVms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {EditVmDto} editVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVm(rgId: string, id: string, editVmDto: EditVmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVm(rgId, id, editVmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.updateVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupVmControllerApi - factory interface
 * @export
 */
export const ResourceGroupVmControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupVmControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} rgId 
         * @param {AddVmDto} addVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVm(rgId: string, addVmDto: AddVmDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addVm(rgId, addVmDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVm(rgId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVm(rgId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableVms(rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VmDto>> {
            return localVarFp.getAvailableVms(rgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm(rgId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<VmDto> {
            return localVarFp.getVm(rgId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms(rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VmDto>> {
            return localVarFp.getVms(rgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {EditVmDto} editVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVm(rgId: string, id: string, editVmDto: EditVmDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateVm(rgId, id, editVmDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupVmControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupVmControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupVmControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} rgId 
     * @param {AddVmDto} addVmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public addVm(rgId: string, addVmDto: AddVmDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).addVm(rgId, addVmDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public deleteVm(rgId: string, id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).deleteVm(rgId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public getAvailableVms(rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).getAvailableVms(rgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public getVm(rgId: string, id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).getVm(rgId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public getVms(rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).getVms(rgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {string} id 
     * @param {EditVmDto} editVmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public updateVm(rgId: string, id: string, editVmDto: EditVmDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).updateVm(rgId, id, editVmDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamControllerApi - axios parameter creator
 * @export
 */
export const TeamControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTeamDto} createTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamDto: CreateTeamDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamDto' is not null or undefined
            assertParamExists('createTeam', 'createTeamDto', createTeamDto)
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDetails: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamDetails', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTeamsByCourse', 'courseId', courseId)
            const localVarPath = `/teams/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTeamsByUser', 'userId', userId)
            const localVarPath = `/teams/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyValue 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinUsingKey: async (keyValue: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyValue' is not null or undefined
            assertParamExists('joinUsingKey', 'keyValue', keyValue)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('joinUsingKey', 'userId', userId)
            const localVarPath = `/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyValue !== undefined) {
                localVarQueryParameter['keyValue'] = keyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeam: async (teamId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('leaveTeam', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('leaveTeam', 'userId', userId)
            const localVarPath = `/teams/leave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTeamDto} updateTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (id: string, updateTeamDto: UpdateTeamDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeam', 'id', id)
            // verify required parameter 'updateTeamDto' is not null or undefined
            assertParamExists('updateTeam', 'updateTeamDto', updateTeamDto)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamControllerApi - functional programming interface
 * @export
 */
export const TeamControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTeamDto} createTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamDto: CreateTeamDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamWithCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.createTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamDetails(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamWithCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamDetails(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeamDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamWithCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsByCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsByCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeamsByCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsByUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamWithCourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsByUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeamsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} keyValue 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinUsingKey(keyValue: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinUsingKey(keyValue, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.joinUsingKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveTeam(teamId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveTeam(teamId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.leaveTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTeamDto} updateTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(id: string, updateTeamDto: UpdateTeamDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamWithCourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(id, updateTeamDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.updateTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamControllerApi - factory interface
 * @export
 */
export const TeamControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTeamDto} createTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamDto: CreateTeamDto, options?: RawAxiosRequestConfig): AxiosPromise<TeamWithCourseDto> {
            return localVarFp.createTeam(createTeamDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDetails(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<TeamWithCourseDto> {
            return localVarFp.getTeamDetails(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamWithCourseDto>> {
            return localVarFp.getTeams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamDto>> {
            return localVarFp.getTeamsByCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamWithCourseDto>> {
            return localVarFp.getTeamsByUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} keyValue 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinUsingKey(keyValue: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.joinUsingKey(keyValue, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeam(teamId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leaveTeam(teamId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTeamDto} updateTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: string, updateTeamDto: UpdateTeamDto, options?: RawAxiosRequestConfig): AxiosPromise<TeamWithCourseDto> {
            return localVarFp.updateTeam(id, updateTeamDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamControllerApi - object-oriented interface
 * @export
 * @class TeamControllerApi
 * @extends {BaseAPI}
 */
export class TeamControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateTeamDto} createTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public createTeam(createTeamDto: CreateTeamDto, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).createTeam(createTeamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeamDetails(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeamDetails(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeams(options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeamsByCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeamsByCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeamsByUser(userId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeamsByUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} keyValue 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public joinUsingKey(keyValue: string, userId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).joinUsingKey(keyValue, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public leaveTeam(teamId: string, userId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).leaveTeam(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTeamDto} updateTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public updateTeam(id: string, updateTeamDto: UpdateTeamDto, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).updateTeam(id, updateTeamDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendHtmlMail: async (mailTo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailTo' is not null or undefined
            assertParamExists('sendHtmlMail', 'mailTo', mailTo)
            const localVarPath = `/test/send-html-mail/{mail-to}`
                .replace(`{${"mail-to"}}`, encodeURIComponent(String(mailTo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSimpleMail: async (mailTo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailTo' is not null or undefined
            assertParamExists('sendSimpleMail', 'mailTo', mailTo)
            const localVarPath = `/test/send-simple-mail/{mail-to}`
                .replace(`{${"mail-to"}}`, encodeURIComponent(String(mailTo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendHtmlMail(mailTo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendHtmlMail(mailTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.sendHtmlMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSimpleMail(mailTo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSimpleMail(mailTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.sendSimpleMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendHtmlMail(mailTo: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendHtmlMail(mailTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSimpleMail(mailTo: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendSimpleMail(mailTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} mailTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public sendHtmlMail(mailTo: string, options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).sendHtmlMail(mailTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} mailTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public sendSimpleMail(mailTo: string, options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).sendSimpleMail(mailTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VlansRangeControllerApi - axios parameter creator
 * @export
 */
export const VlansRangeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateVlansRangeDto} createVlansRangeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVlansRange: async (createVlansRangeDto: CreateVlansRangeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVlansRangeDto' is not null or undefined
            assertParamExists('addVlansRange', 'createVlansRangeDto', createVlansRangeDto)
            const localVarPath = `/resources/vnic-profiles/vlans-range/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVlansRangeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRange: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVlansRange', 'id', id)
            const localVarPath = `/resources/vnic-profiles/vlans-range/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [sorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRanges: async (sorted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles/vlans-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sorted !== undefined) {
                localVarQueryParameter['sorted'] = sorted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVlansRange: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeVlansRange', 'id', id)
            const localVarPath = `/resources/vnic-profiles/vlans-range/{id}/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VlansRangeControllerApi - functional programming interface
 * @export
 */
export const VlansRangeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VlansRangeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateVlansRangeDto} createVlansRangeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVlansRange(createVlansRangeDto: CreateVlansRangeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VlansRangeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVlansRange(createVlansRangeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.addVlansRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVlansRange(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VlansRangeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVlansRange(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.getVlansRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [sorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVlansRanges(sorted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VlansRangeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVlansRanges(sorted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.getVlansRanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVlansRange(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeVlansRange(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.removeVlansRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VlansRangeControllerApi - factory interface
 * @export
 */
export const VlansRangeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VlansRangeControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateVlansRangeDto} createVlansRangeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVlansRange(createVlansRangeDto: CreateVlansRangeDto, options?: RawAxiosRequestConfig): AxiosPromise<VlansRangeDto> {
            return localVarFp.addVlansRange(createVlansRangeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRange(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VlansRangeDto> {
            return localVarFp.getVlansRange(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [sorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRanges(sorted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<VlansRangeDto>> {
            return localVarFp.getVlansRanges(sorted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVlansRange(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeVlansRange(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VlansRangeControllerApi - object-oriented interface
 * @export
 * @class VlansRangeControllerApi
 * @extends {BaseAPI}
 */
export class VlansRangeControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateVlansRangeDto} createVlansRangeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public addVlansRange(createVlansRangeDto: CreateVlansRangeDto, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).addVlansRange(createVlansRangeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public getVlansRange(id: string, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).getVlansRange(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [sorted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public getVlansRanges(sorted?: boolean, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).getVlansRanges(sorted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public removeVlansRange(id: string, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).removeVlansRange(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VmControllerApi - axios parameter creator
 * @export
 */
export const VmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsForVm: async (id: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findEventsForVm', 'id', id)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findEventsForVm', 'pageable', pageable)
            const localVarPath = `/resource/vm/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVmRequiredResources: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findVmRequiredResources', 'id', id)
            const localVarPath = `/resource/vm/{id}/required-resources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVmsForCluster: async (clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('findVmsForCluster', 'clusterId', clusterId)
            const localVarPath = `/resource/vm/clusters/{clusterId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVm1', 'id', id)
            const localVarPath = `/resource/vm/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource/vm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmControllerApi - functional programming interface
 * @export
 */
export const VmControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventsForVm(id: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findEventsForVm(id, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.findEventsForVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findVmRequiredResources(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourcesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findVmRequiredResources(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.findVmRequiredResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findVmsForCluster(clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findVmsForCluster(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.findVmsForCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVm1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVm1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.getVm1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVms1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVms1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.getVms1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VmControllerApi - factory interface
 * @export
 */
export const VmControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsForVm(id: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventGeneralDto>> {
            return localVarFp.findEventsForVm(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVmRequiredResources(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourcesDto> {
            return localVarFp.findVmRequiredResources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVmsForCluster(clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VmDto>> {
            return localVarFp.findVmsForCluster(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VmDto> {
            return localVarFp.getVm1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VmDto>> {
            return localVarFp.getVms1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmControllerApi - object-oriented interface
 * @export
 * @class VmControllerApi
 * @extends {BaseAPI}
 */
export class VmControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public findEventsForVm(id: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).findEventsForVm(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public findVmRequiredResources(id: string, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).findVmRequiredResources(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public findVmsForCluster(clusterId: string, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).findVmsForCluster(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public getVm1(id: string, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).getVm1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public getVms1(options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).getVms1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VnicProfileControllerApi - axios parameter creator
 * @export
 */
export const VnicProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendVnicProfilesPool: async (vnicProfileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vnicProfileId' is not null or undefined
            assertParamExists('extendVnicProfilesPool', 'vnicProfileId', vnicProfileId)
            const localVarPath = `/resources/vnic-profiles/eduvirt/add-to-pool/{vnicProfileId}`
                .replace(`{${"vnicProfileId"}}`, encodeURIComponent(String(vnicProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvirtVnicProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles/ovirt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynchronizedVnicProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfileFromPool: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVnicProfileFromPool', 'id', id)
            const localVarPath = `/resources/vnic-profiles/eduvirt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfilesFromPool: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles/eduvirt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reduceVnicProfilesPool: async (vnicProfileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vnicProfileId' is not null or undefined
            assertParamExists('reduceVnicProfilesPool', 'vnicProfileId', vnicProfileId)
            const localVarPath = `/resources/vnic-profiles/eduvirt/remove-from-pool/{vnicProfileId}`
                .replace(`{${"vnicProfileId"}}`, encodeURIComponent(String(vnicProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VnicProfileControllerApi - functional programming interface
 * @export
 */
export const VnicProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VnicProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VnicProfilePoolMemberDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendVnicProfilesPool(vnicProfileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.extendVnicProfilesPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOvirtVnicProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VnicProfileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOvirtVnicProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getOvirtVnicProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSynchronizedVnicProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VnicProfileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSynchronizedVnicProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getSynchronizedVnicProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVnicProfileFromPool(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VnicProfilePoolMemberDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVnicProfileFromPool(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getVnicProfileFromPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVnicProfilesFromPool(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VnicProfilePoolMemberDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVnicProfilesFromPool(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getVnicProfilesFromPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reduceVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reduceVnicProfilesPool(vnicProfileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.reduceVnicProfilesPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VnicProfileControllerApi - factory interface
 * @export
 */
export const VnicProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VnicProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): AxiosPromise<VnicProfilePoolMemberDto> {
            return localVarFp.extendVnicProfilesPool(vnicProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvirtVnicProfiles(options?: RawAxiosRequestConfig): AxiosPromise<Array<VnicProfileDto>> {
            return localVarFp.getOvirtVnicProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynchronizedVnicProfiles(options?: RawAxiosRequestConfig): AxiosPromise<Array<VnicProfileDto>> {
            return localVarFp.getSynchronizedVnicProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfileFromPool(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VnicProfilePoolMemberDto> {
            return localVarFp.getVnicProfileFromPool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfilesFromPool(options?: RawAxiosRequestConfig): AxiosPromise<Array<VnicProfilePoolMemberDto>> {
            return localVarFp.getVnicProfilesFromPool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reduceVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reduceVnicProfilesPool(vnicProfileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VnicProfileControllerApi - object-oriented interface
 * @export
 * @class VnicProfileControllerApi
 * @extends {BaseAPI}
 */
export class VnicProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} vnicProfileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public extendVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).extendVnicProfilesPool(vnicProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getOvirtVnicProfiles(options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getOvirtVnicProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getSynchronizedVnicProfiles(options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getSynchronizedVnicProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getVnicProfileFromPool(id: string, options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getVnicProfileFromPool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getVnicProfilesFromPool(options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getVnicProfilesFromPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vnicProfileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public reduceVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).reduceVnicProfilesPool(vnicProfileId, options).then((request) => request(this.axios, this.basePath));
    }
}



