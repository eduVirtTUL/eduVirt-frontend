/* tslint:disable */
/* eslint-disable */
/**
 * eduVirt
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddVmDto
 */
export interface AddVmDto {
    /**
     * 
     * @type {string}
     * @memberof AddVmDto
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddVmDto
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterDetailsDto
 */
export interface ClusterDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'clusterCpuType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'compatibilityVersion'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterDetailsDto
     */
    'threadsAsCores'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterDetailsDto
     */
    'maxMemoryOverCommit'?: string;
}
/**
 * 
 * @export
 * @interface ClusterGeneralDto
 */
export interface ClusterGeneralDto {
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'clusterCpuType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGeneralDto
     */
    'compatibilityVersion'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterGeneralDto
     */
    'hostCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterGeneralDto
     */
    'vmCount'?: number;
}
/**
 * 
 * @export
 * @interface CourseDto
 */
export interface CourseDto {
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CourseDto
     */
    'teamBased'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CourseDto
     */
    'courseKey'?: string;
}
/**
 * 
 * @export
 * @interface CreateCourseDto
 */
export interface CreateCourseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCourseDto
     */
    'teamBased'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCourseDto
     */
    'clusterId'?: string;
}
/**
 * 
 * @export
 * @interface CreateMaintenanceIntervalDto
 */
export interface CreateMaintenanceIntervalDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'cause': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'beginAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMaintenanceIntervalDto
     */
    'endAt': string;
}
/**
 * 
 * @export
 * @interface CreateMetricDto
 */
export interface CreateMetricDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateMetricValueDto
 */
export interface CreateMetricValueDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricValueDto
     */
    'metricId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMetricValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CreatePodStatefulDto
 */
export interface CreatePodStatefulDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatefulDto
     */
    'resourceGroupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatefulDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatefulDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePodStatefulDto
     */
    'clusterId'?: string;
}
/**
 * 
 * @export
 * @interface CreateRGPoolDto
 */
export interface CreateRGPoolDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRGPoolDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRGPoolDto
     */
    'courseId'?: string;
}
/**
 * 
 * @export
 * @interface CreateReservationDto
 */
export interface CreateReservationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateReservationDto
     */
    'resourceGroupId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReservationDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReservationDto
     */
    'end': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateReservationDto
     */
    'automaticStartup'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateResourceGroupDto
 */
export interface CreateResourceGroupDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceGroupDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateResourceGroupDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateResourceGroupDto
     */
    'stateless'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateResourceGroupNetworkDto
 */
export interface CreateResourceGroupNetworkDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceGroupNetworkDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateTeamDto
 */
export interface CreateTeamDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamDto
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTeamDto
     */
    'maxSize'?: number;
}
/**
 * 
 * @export
 * @interface CreateVlansRangeDto
 */
export interface CreateVlansRangeDto {
    /**
     * 
     * @type {number}
     * @memberof CreateVlansRangeDto
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateVlansRangeDto
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface DetailedResourceGroupPoolDto
 */
export interface DetailedResourceGroupPoolDto {
    /**
     * 
     * @type {string}
     * @memberof DetailedResourceGroupPoolDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailedResourceGroupPoolDto
     */
    'name'?: string;
    /**
     * 
     * @type {CourseDto}
     * @memberof DetailedResourceGroupPoolDto
     */
    'course'?: CourseDto;
}
/**
 * 
 * @export
 * @interface EventGeneralDto
 */
export interface EventGeneralDto {
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'severity'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGeneralDto
     */
    'registeredAt'?: string;
}
/**
 * 
 * @export
 * @interface ExceptionResponse
 */
export interface ExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponse
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface HostDto
 */
export interface HostDto {
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostDto
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof HostDto
     */
    'cpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof HostDto
     */
    'memory'?: number;
}
/**
 * 
 * @export
 * @interface MaintenanceIntervalDetailsDto
 */
export interface MaintenanceIntervalDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'cause'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'clusterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'beginAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDetailsDto
     */
    'endAt'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceIntervalDto
 */
export interface MaintenanceIntervalDto {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'cause'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'clusterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'beginAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceIntervalDto
     */
    'endAt'?: string;
}
/**
 * 
 * @export
 * @interface MetricDto
 */
export interface MetricDto {
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MetricValueDto
 */
export interface MetricValueDto {
    /**
     * 
     * @type {string}
     * @memberof MetricValueDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricValueDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof MetricValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface NetworkDto
 */
export interface NetworkDto {
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkDto
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface NetworkVmConnectionDto
 */
export interface NetworkVmConnectionDto {
    /**
     * 
     * @type {string}
     * @memberof NetworkVmConnectionDto
     */
    'vmId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkVmConnectionDto
     */
    'nicId'?: string;
}
/**
 * 
 * @export
 * @interface NicDto
 */
export interface NicDto {
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'profileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'segmentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NicDto
     */
    'macAddress'?: string;
}
/**
 * 
 * @export
 * @interface PageDtoMaintenanceIntervalDto
 */
export interface PageDtoMaintenanceIntervalDto {
    /**
     * 
     * @type {Array<MaintenanceIntervalDto>}
     * @memberof PageDtoMaintenanceIntervalDto
     */
    'items'?: Array<MaintenanceIntervalDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoMaintenanceIntervalDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoMetricDto
 */
export interface PageDtoMetricDto {
    /**
     * 
     * @type {Array<MetricDto>}
     * @memberof PageDtoMetricDto
     */
    'items'?: Array<MetricDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoMetricDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoMetricValueDto
 */
export interface PageDtoMetricValueDto {
    /**
     * 
     * @type {Array<MetricValueDto>}
     * @memberof PageDtoMetricValueDto
     */
    'items'?: Array<MetricValueDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoMetricValueDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageDtoReservationDto
 */
export interface PageDtoReservationDto {
    /**
     * 
     * @type {Array<ReservationDto>}
     * @memberof PageDtoReservationDto
     */
    'items'?: Array<ReservationDto>;
    /**
     * 
     * @type {PageInfoDto}
     * @memberof PageDtoReservationDto
     */
    'page'?: PageInfoDto;
}
/**
 * 
 * @export
 * @interface PageInfoDto
 */
export interface PageInfoDto {
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'elements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoDto
     */
    'totalElements'?: number;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PodStatefulDto
 */
export interface PodStatefulDto {
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'resourceGroupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'courseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStatefulDto
     */
    'clusterId'?: string;
}
/**
 * 
 * @export
 * @interface ReservationDetailsDto
 */
export interface ReservationDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'resourceGroupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDetailsDto
     */
    'end'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReservationDetailsDto
     */
    'automaticStartup'?: boolean;
}
/**
 * 
 * @export
 * @interface ReservationDto
 */
export interface ReservationDto {
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReservationDto
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface ResourceGroupDto
 */
export interface ResourceGroupDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupDto
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceGroupDto
     */
    'stateless'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceGroupNetworkDto
 */
export interface ResourceGroupNetworkDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupNetworkDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupNetworkDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ResourceGroupPoolDto
 */
export interface ResourceGroupPoolDto {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupPoolDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupPoolDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ResourcesAvailabilityDto
 */
export interface ResourcesAvailabilityDto {
    /**
     * 
     * @type {string}
     * @memberof ResourcesAvailabilityDto
     */
    'time'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourcesAvailabilityDto
     */
    'available'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourcesDto
 */
export interface ResourcesDto {
    /**
     * 
     * @type {number}
     * @memberof ResourcesDto
     */
    'cpuCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourcesDto
     */
    'memorySize'?: number;
}
/**
 * 
 * @export
 * @interface SetCourseKeyDto
 */
export interface SetCourseKeyDto {
    /**
     * 
     * @type {string}
     * @memberof SetCourseKeyDto
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface TeamDto
 */
export interface TeamDto {
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'key'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TeamDto
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamDto
     */
    'users'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'course'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricValueDto
 */
export interface UpdateMetricValueDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface ValueDto
 */
export interface ValueDto {
    /**
     * 
     * @type {number}
     * @memberof ValueDto
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface VlansRangeDto
 */
export interface VlansRangeDto {
    /**
     * 
     * @type {string}
     * @memberof VlansRangeDto
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VlansRangeDto
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof VlansRangeDto
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface VmDto
 */
export interface VmDto {
    /**
     * 
     * @type {string}
     * @memberof VmDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VmDto
     */
    'cpuCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmDto
     */
    'memory'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VmDto
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {Array<NicDto>}
     * @memberof VmDto
     */
    'nics'?: Array<NicDto>;
}
/**
 * 
 * @export
 * @interface VmGeneralDto
 */
export interface VmGeneralDto {
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'uptimeSeconds'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'cpuUsagePercentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'memoryUsagePercentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof VmGeneralDto
     */
    'networkUsagePercentage'?: string;
}
/**
 * 
 * @export
 * @interface VnicProfileDto
 */
export interface VnicProfileDto {
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'networkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'networkName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfileDto
     */
    'networkVlanId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VnicProfileDto
     */
    'inPool'?: boolean;
}
/**
 * 
 * @export
 * @interface VnicProfilePoolMemberDto
 */
export interface VnicProfilePoolMemberDto {
    /**
     * 
     * @type {string}
     * @memberof VnicProfilePoolMemberDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VnicProfilePoolMemberDto
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VnicProfilePoolMemberDto
     */
    'inUse'?: boolean;
}

/**
 * AssignedPermissionControllerApi - axios parameter creator
 * @export
 */
export const AssignedPermissionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} vmId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermissionToVmToUser: async (vmId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('assignPermissionToVmToUser', 'vmId', vmId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignPermissionToVmToUser', 'userId', userId)
            const localVarPath = `/resources/permissions/vm/{vmId}/user/{userId}`
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findPermissionByUserId', 'userId', userId)
            const localVarPath = `/resources/permissions/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByVmId: async (vmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('findPermissionByVmId', 'vmId', vmId)
            const localVarPath = `/resources/permissions/vm/{vmId}`
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionToVmFromUser: async (permissionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('revokePermissionToVmFromUser', 'permissionId', permissionId)
            const localVarPath = `/resources/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignedPermissionControllerApi - functional programming interface
 * @export
 */
export const AssignedPermissionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignedPermissionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} vmId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignPermissionToVmToUser(vmId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionToVmToUser(vmId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssignedPermissionControllerApi.assignPermissionToVmToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPermissionByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPermissionByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssignedPermissionControllerApi.findPermissionByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPermissionByVmId(vmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPermissionByVmId(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssignedPermissionControllerApi.findPermissionByVmId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokePermissionToVmFromUser(permissionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokePermissionToVmFromUser(permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssignedPermissionControllerApi.revokePermissionToVmFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssignedPermissionControllerApi - factory interface
 * @export
 */
export const AssignedPermissionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignedPermissionControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} vmId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermissionToVmToUser(vmId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignPermissionToVmToUser(vmId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByUserId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.findPermissionByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPermissionByVmId(vmId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.findPermissionByVmId(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionToVmFromUser(permissionId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.revokePermissionToVmFromUser(permissionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssignedPermissionControllerApi - object-oriented interface
 * @export
 * @class AssignedPermissionControllerApi
 * @extends {BaseAPI}
 */
export class AssignedPermissionControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} vmId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignedPermissionControllerApi
     */
    public assignPermissionToVmToUser(vmId: string, userId: string, options?: RawAxiosRequestConfig) {
        return AssignedPermissionControllerApiFp(this.configuration).assignPermissionToVmToUser(vmId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignedPermissionControllerApi
     */
    public findPermissionByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return AssignedPermissionControllerApiFp(this.configuration).findPermissionByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignedPermissionControllerApi
     */
    public findPermissionByVmId(vmId: string, options?: RawAxiosRequestConfig) {
        return AssignedPermissionControllerApiFp(this.configuration).findPermissionByVmId(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignedPermissionControllerApi
     */
    public revokePermissionToVmFromUser(permissionId: string, options?: RawAxiosRequestConfig) {
        return AssignedPermissionControllerApiFp(this.configuration).revokePermissionToVmFromUser(permissionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterControllerApi - axios parameter creator
 * @export
 */
export const ClusterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClusters: async (pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClusterById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findClusterById', 'id', id)
            const localVarPath = `/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClusterResourcesAvailability: async (id: string, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findClusterResourcesAvailability', 'id', id)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findClusterResourcesAvailability', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findClusterResourcesAvailability', 'end', end)
            const localVarPath = `/clusters/{id}/availability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsByClusterId: async (pageable: Pageable, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findEventsByClusterId', 'pageable', pageable)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findEventsByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHostInfoByClusterId: async (id: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findHostInfoByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/hosts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNetworksByClusterId: async (id: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findNetworksByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVirtualMachinesByClusterId: async (id: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findVirtualMachinesByClusterId', 'id', id)
            const localVarPath = `/clusters/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterControllerApi - functional programming interface
 * @export
 */
export const ClusterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllClusters(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClusterGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllClusters(pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findAllClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClusterById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClusterById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findClusterById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClusterResourcesAvailability(id: string, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourcesAvailabilityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClusterResourcesAvailability(id, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findClusterResourcesAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventsByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findEventsByClusterId(pageable, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findEventsByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findHostInfoByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HostDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findHostInfoByClusterId(id, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findHostInfoByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findNetworksByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findNetworksByClusterId(id, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findNetworksByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findVirtualMachinesByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findVirtualMachinesByClusterId(id, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterControllerApi.findVirtualMachinesByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterControllerApi - factory interface
 * @export
 */
export const ClusterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClusters(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClusterGeneralDto>> {
            return localVarFp.findAllClusters(pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClusterById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterDetailsDto> {
            return localVarFp.findClusterById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClusterResourcesAvailability(id: string, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourcesAvailabilityDto>> {
            return localVarFp.findClusterResourcesAvailability(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventGeneralDto>> {
            return localVarFp.findEventsByClusterId(pageable, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHostInfoByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<HostDto>> {
            return localVarFp.findHostInfoByClusterId(id, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNetworksByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<NetworkDto>> {
            return localVarFp.findNetworksByClusterId(id, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVirtualMachinesByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VmGeneralDto>> {
            return localVarFp.findVirtualMachinesByClusterId(id, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterControllerApi - object-oriented interface
 * @export
 * @class ClusterControllerApi
 * @extends {BaseAPI}
 */
export class ClusterControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findAllClusters(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findAllClusters(pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findClusterById(id: string, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findClusterById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findClusterResourcesAvailability(id: string, start: string, end: string, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findClusterResourcesAvailability(id, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findEventsByClusterId(pageable: Pageable, id: string, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findEventsByClusterId(pageable, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findHostInfoByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findHostInfoByClusterId(id, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findNetworksByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findNetworksByClusterId(id, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterControllerApi
     */
    public findVirtualMachinesByClusterId(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterControllerApiFp(this.configuration).findVirtualMachinesByClusterId(id, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterMetricControllerApi - axios parameter creator
 * @export
 */
export const ClusterMetricControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricValue: async (clusterId: string, createMetricValueDto: CreateMetricValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createMetricValue', 'clusterId', clusterId)
            // verify required parameter 'createMetricValueDto' is not null or undefined
            assertParamExists('createMetricValue', 'createMetricValueDto', createMetricValueDto)
            const localVarPath = `/clusters/{clusterId}/metrics`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric1: async (clusterId: string, metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteMetric1', 'clusterId', clusterId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('deleteMetric1', 'metricId', metricId)
            const localVarPath = `/clusters/{clusterId}/metrics/{metricId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetricValues: async (clusterId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getAllMetricValues', 'clusterId', clusterId)
            const localVarPath = `/clusters/{clusterId}/metrics`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {ValueDto} valueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetricValue: async (clusterId: string, metricId: string, valueDto: ValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateMetricValue', 'clusterId', clusterId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('updateMetricValue', 'metricId', metricId)
            // verify required parameter 'valueDto' is not null or undefined
            assertParamExists('updateMetricValue', 'valueDto', valueDto)
            const localVarPath = `/clusters/{clusterId}/metrics/{metricId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterMetricControllerApi - functional programming interface
 * @export
 */
export const ClusterMetricControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterMetricControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricValue(clusterId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricValue(clusterId, createMetricValueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.createMetricValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric1(clusterId: string, metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric1(clusterId, metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.deleteMetric1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMetricValues(clusterId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoMetricValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMetricValues(clusterId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.getAllMetricValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {ValueDto} valueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetricValue(clusterId: string, metricId: string, valueDto: ValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetricValue(clusterId, metricId, valueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricControllerApi.updateMetricValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterMetricControllerApi - factory interface
 * @export
 */
export const ClusterMetricControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterMetricControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricValue(clusterId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createMetricValue(clusterId, createMetricValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric1(clusterId: string, metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMetric1(clusterId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetricValues(clusterId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoMetricValueDto> {
            return localVarFp.getAllMetricValues(clusterId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} metricId 
         * @param {ValueDto} valueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetricValue(clusterId: string, metricId: string, valueDto: ValueDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricValueDto> {
            return localVarFp.updateMetricValue(clusterId, metricId, valueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterMetricControllerApi - object-oriented interface
 * @export
 * @class ClusterMetricControllerApi
 * @extends {BaseAPI}
 */
export class ClusterMetricControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} clusterId 
     * @param {CreateMetricValueDto} createMetricValueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public createMetricValue(clusterId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).createMetricValue(clusterId, createMetricValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public deleteMetric1(clusterId: string, metricId: string, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).deleteMetric1(clusterId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public getAllMetricValues(clusterId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).getAllMetricValues(clusterId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clusterId 
     * @param {string} metricId 
     * @param {ValueDto} valueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricControllerApi
     */
    public updateMetricValue(clusterId: string, metricId: string, valueDto: ValueDto, options?: RawAxiosRequestConfig) {
        return ClusterMetricControllerApiFp(this.configuration).updateMetricValue(clusterId, metricId, valueDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseControllerApi - axios parameter creator
 * @export
 */
export const CourseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCourse: async (createCourseDto: CreateCourseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseDto' is not null or undefined
            assertParamExists('addCourse', 'createCourseDto', createCourseDto)
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCourseResourcesAvailability: async (id: string, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findCourseResourcesAvailability', 'id', id)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findCourseResourcesAvailability', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findCourseResourcesAvailability', 'end', end)
            const localVarPath = `/course/{id}/availability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourse', 'id', id)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResourceGroupPools: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseResourceGroupPools', 'id', id)
            const localVarPath = `/course/{id}/resource-group-pools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SetCourseKeyDto} setCourseKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCourseKey: async (id: string, setCourseKeyDto: SetCourseKeyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCourseKey', 'id', id)
            // verify required parameter 'setCourseKeyDto' is not null or undefined
            assertParamExists('setCourseKey', 'setCourseKeyDto', setCourseKeyDto)
            const localVarPath = `/course/{id}/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCourseKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseControllerApi - functional programming interface
 * @export
 */
export const CourseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCourse(createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCourse(createCourseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.addCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCourseResourcesAvailability(id: string, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourcesAvailabilityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCourseResourcesAvailability(id, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.findCourseResourcesAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseResourceGroupPools(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupPoolDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseResourceGroupPools(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourseResourceGroupPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.getCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SetCourseKeyDto} setCourseKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCourseKey(id: string, setCourseKeyDto: SetCourseKeyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCourseKey(id, setCourseKeyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseControllerApi.setCourseKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseControllerApi - factory interface
 * @export
 */
export const CourseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCourseDto} createCourseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCourse(createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig): AxiosPromise<CourseDto> {
            return localVarFp.addCourse(createCourseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCourseResourcesAvailability(id: string, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourcesAvailabilityDto>> {
            return localVarFp.findCourseResourcesAvailability(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseDto> {
            return localVarFp.getCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseResourceGroupPools(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupPoolDto>> {
            return localVarFp.getCourseResourceGroupPools(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(options?: RawAxiosRequestConfig): AxiosPromise<Array<CourseDto>> {
            return localVarFp.getCourses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SetCourseKeyDto} setCourseKeyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCourseKey(id: string, setCourseKeyDto: SetCourseKeyDto, options?: RawAxiosRequestConfig): AxiosPromise<CourseDto> {
            return localVarFp.setCourseKey(id, setCourseKeyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseControllerApi - object-oriented interface
 * @export
 * @class CourseControllerApi
 * @extends {BaseAPI}
 */
export class CourseControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCourseDto} createCourseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public addCourse(createCourseDto: CreateCourseDto, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).addCourse(createCourseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public findCourseResourcesAvailability(id: string, start: string, end: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).findCourseResourcesAvailability(id, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourse(id: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourseResourceGroupPools(id: string, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourseResourceGroupPools(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public getCourses(options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).getCourses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SetCourseKeyDto} setCourseKeyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseControllerApi
     */
    public setCourseKey(id: string, setCourseKeyDto: SetCourseKeyDto, options?: RawAxiosRequestConfig) {
        return CourseControllerApiFp(this.configuration).setCourseKey(id, setCourseKeyDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseMetricControllerApi - axios parameter creator
 * @export
 */
export const CourseMetricControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric: async (courseId: string, createMetricValueDto: CreateMetricValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('createMetric', 'courseId', courseId)
            // verify required parameter 'createMetricValueDto' is not null or undefined
            assertParamExists('createMetric', 'createMetricValueDto', createMetricValueDto)
            const localVarPath = `/course/{courseId}/metric`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric: async (courseId: string, metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('deleteMetric', 'courseId', courseId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('deleteMetric', 'metricId', metricId)
            const localVarPath = `/course/{courseId}/metric/{metricId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (courseId: string, metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMetric', 'courseId', courseId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('getMetric', 'metricId', metricId)
            const localVarPath = `/course/{courseId}/metric/{metricId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getMetrics', 'courseId', courseId)
            const localVarPath = `/course/{courseId}/metric`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {UpdateMetricValueDto} updateMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetric: async (courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('updateMetric', 'courseId', courseId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('updateMetric', 'metricId', metricId)
            // verify required parameter 'updateMetricValueDto' is not null or undefined
            assertParamExists('updateMetric', 'updateMetricValueDto', updateMetricValueDto)
            const localVarPath = `/course/{courseId}/metric/{metricId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricValueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseMetricControllerApi - functional programming interface
 * @export
 */
export const CourseMetricControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseMetricControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetric(courseId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetric(courseId, createMetricValueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.createMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric(courseId, metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.deleteMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricValueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(courseId, metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.getMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetricValueDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.getMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {UpdateMetricValueDto} updateMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetric(courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetric(courseId, metricId, updateMetricValueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseMetricControllerApi.updateMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseMetricControllerApi - factory interface
 * @export
 */
export const CourseMetricControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseMetricControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} courseId 
         * @param {CreateMetricValueDto} createMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric(courseId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createMetric(courseId, createMetricValueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMetric(courseId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricValueDto> {
            return localVarFp.getMetric(courseId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MetricValueDto>> {
            return localVarFp.getMetrics(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {string} metricId 
         * @param {UpdateMetricValueDto} updateMetricValueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetric(courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMetric(courseId, metricId, updateMetricValueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseMetricControllerApi - object-oriented interface
 * @export
 * @class CourseMetricControllerApi
 * @extends {BaseAPI}
 */
export class CourseMetricControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} courseId 
     * @param {CreateMetricValueDto} createMetricValueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public createMetric(courseId: string, createMetricValueDto: CreateMetricValueDto, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).createMetric(courseId, createMetricValueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public deleteMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).deleteMetric(courseId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public getMetric(courseId: string, metricId: string, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).getMetric(courseId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public getMetrics(courseId: string, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).getMetrics(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {string} metricId 
     * @param {UpdateMetricValueDto} updateMetricValueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseMetricControllerApi
     */
    public updateMetric(courseId: string, metricId: string, updateMetricValueDto: UpdateMetricValueDto, options?: RawAxiosRequestConfig) {
        return CourseMetricControllerApiFp(this.configuration).updateMetric(courseId, metricId, updateMetricValueDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaintenanceIntervalControllerApi - axios parameter creator
 * @export
 */
export const MaintenanceIntervalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewClusterMaintenanceInterval: async (clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createNewClusterMaintenanceInterval', 'clusterId', clusterId)
            // verify required parameter 'createMaintenanceIntervalDto' is not null or undefined
            assertParamExists('createNewClusterMaintenanceInterval', 'createMaintenanceIntervalDto', createMaintenanceIntervalDto)
            const localVarPath = `/maintenance-intervals/cluster/{clusterId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaintenanceIntervalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSystemMaintenanceInterval: async (createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMaintenanceIntervalDto' is not null or undefined
            assertParamExists('createNewSystemMaintenanceInterval', 'createMaintenanceIntervalDto', createMaintenanceIntervalDto)
            const localVarPath = `/maintenance-intervals/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaintenanceIntervalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishMaintenanceInterval: async (intervalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'intervalId' is not null or undefined
            assertParamExists('finishMaintenanceInterval', 'intervalId', intervalId)
            const localVarPath = `/maintenance-intervals/{intervalId}`
                .replace(`{${"intervalId"}}`, encodeURIComponent(String(intervalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [clusterId] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaintenanceIntervals: async (pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/maintenance-intervals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['clusterId'] = clusterId;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceInterval: async (intervalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'intervalId' is not null or undefined
            assertParamExists('getMaintenanceInterval', 'intervalId', intervalId)
            const localVarPath = `/maintenance-intervals/{intervalId}`
                .replace(`{${"intervalId"}}`, encodeURIComponent(String(intervalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} start 
         * @param {string} end 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceIntervalsWithinTimePeriod: async (start: string, end: string, clusterId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getMaintenanceIntervalsWithinTimePeriod', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getMaintenanceIntervalsWithinTimePeriod', 'end', end)
            const localVarPath = `/maintenance-intervals/time-period`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clusterId !== undefined) {
                localVarQueryParameter['clusterId'] = clusterId;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintenanceIntervalControllerApi - functional programming interface
 * @export
 */
export const MaintenanceIntervalControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceIntervalControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewClusterMaintenanceInterval(clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewClusterMaintenanceInterval(clusterId, createMaintenanceIntervalDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.createNewClusterMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewSystemMaintenanceInterval(createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewSystemMaintenanceInterval(createMaintenanceIntervalDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.createNewSystemMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishMaintenanceInterval(intervalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.finishMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [clusterId] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMaintenanceIntervals(pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoMaintenanceIntervalDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMaintenanceIntervals(pageNumber, pageSize, clusterId, active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.getAllMaintenanceIntervals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceIntervalDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceInterval(intervalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.getMaintenanceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} start 
         * @param {string} end 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceIntervalsWithinTimePeriod(start: string, end: string, clusterId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintenanceIntervalDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceIntervalsWithinTimePeriod(start, end, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceIntervalControllerApi.getMaintenanceIntervalsWithinTimePeriod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaintenanceIntervalControllerApi - factory interface
 * @export
 */
export const MaintenanceIntervalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintenanceIntervalControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} clusterId 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewClusterMaintenanceInterval(clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewClusterMaintenanceInterval(clusterId, createMaintenanceIntervalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSystemMaintenanceInterval(createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewSystemMaintenanceInterval(createMaintenanceIntervalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.finishMaintenanceInterval(intervalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [clusterId] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaintenanceIntervals(pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoMaintenanceIntervalDto> {
            return localVarFp.getAllMaintenanceIntervals(pageNumber, pageSize, clusterId, active, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} intervalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceIntervalDetailsDto> {
            return localVarFp.getMaintenanceInterval(intervalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} start 
         * @param {string} end 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceIntervalsWithinTimePeriod(start: string, end: string, clusterId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MaintenanceIntervalDto>> {
            return localVarFp.getMaintenanceIntervalsWithinTimePeriod(start, end, clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaintenanceIntervalControllerApi - object-oriented interface
 * @export
 * @class MaintenanceIntervalControllerApi
 * @extends {BaseAPI}
 */
export class MaintenanceIntervalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} clusterId 
     * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public createNewClusterMaintenanceInterval(clusterId: string, createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).createNewClusterMaintenanceInterval(clusterId, createMaintenanceIntervalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMaintenanceIntervalDto} createMaintenanceIntervalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public createNewSystemMaintenanceInterval(createMaintenanceIntervalDto: CreateMaintenanceIntervalDto, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).createNewSystemMaintenanceInterval(createMaintenanceIntervalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} intervalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public finishMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).finishMaintenanceInterval(intervalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {string} [clusterId] 
     * @param {boolean} [active] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public getAllMaintenanceIntervals(pageNumber?: number, pageSize?: number, clusterId?: string, active?: boolean, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).getAllMaintenanceIntervals(pageNumber, pageSize, clusterId, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} intervalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public getMaintenanceInterval(intervalId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).getMaintenanceInterval(intervalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} start 
     * @param {string} end 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceIntervalControllerApi
     */
    public getMaintenanceIntervalsWithinTimePeriod(start: string, end: string, clusterId?: string, options?: RawAxiosRequestConfig) {
        return MaintenanceIntervalControllerApiFp(this.configuration).getMaintenanceIntervalsWithinTimePeriod(start, end, clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricControllerApi - axios parameter creator
 * @export
 */
export const MetricControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMetricDto} createMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMetric: async (createMetricDto: CreateMetricDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMetricDto' is not null or undefined
            assertParamExists('createNewMetric', 'createMetricDto', createMetricDto)
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric2: async (metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('deleteMetric2', 'metricId', metricId)
            const localVarPath = `/metrics/{metricId}`
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetrics: async (pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricControllerApi - functional programming interface
 * @export
 */
export const MetricControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateMetricDto} createMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewMetric(createMetricDto: CreateMetricDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewMetric(createMetricDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricControllerApi.createNewMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric2(metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric2(metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricControllerApi.deleteMetric2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMetrics(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMetrics(pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricControllerApi.getAllMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricControllerApi - factory interface
 * @export
 */
export const MetricControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateMetricDto} createMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMetric(createMetricDto: CreateMetricDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewMetric(createMetricDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} metricId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric2(metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMetric2(metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMetrics(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoMetricDto> {
            return localVarFp.getAllMetrics(pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricControllerApi - object-oriented interface
 * @export
 * @class MetricControllerApi
 * @extends {BaseAPI}
 */
export class MetricControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateMetricDto} createMetricDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricControllerApi
     */
    public createNewMetric(createMetricDto: CreateMetricDto, options?: RawAxiosRequestConfig) {
        return MetricControllerApiFp(this.configuration).createNewMetric(createMetricDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} metricId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricControllerApi
     */
    public deleteMetric2(metricId: string, options?: RawAxiosRequestConfig) {
        return MetricControllerApiFp(this.configuration).deleteMetric2(metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricControllerApi
     */
    public getAllMetrics(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return MetricControllerApiFp(this.configuration).getAllMetrics(pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OVirtUserControllerApi - axios parameter creator
 * @export
 */
export const OVirtUserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/resources/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OVirtUserControllerApi - functional programming interface
 * @export
 */
export const OVirtUserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OVirtUserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OVirtUserControllerApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OVirtUserControllerApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OVirtUserControllerApi - factory interface
 * @export
 */
export const OVirtUserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OVirtUserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OVirtUserControllerApi - object-oriented interface
 * @export
 * @class OVirtUserControllerApi
 * @extends {BaseAPI}
 */
export class OVirtUserControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OVirtUserControllerApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return OVirtUserControllerApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OVirtUserControllerApi
     */
    public getUserById(userId: string, options?: RawAxiosRequestConfig) {
        return OVirtUserControllerApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PodStatefulControllerApi - axios parameter creator
 * @export
 */
export const PodStatefulControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePodStatefulDto} createPodStatefulDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPod: async (createPodStatefulDto: CreatePodStatefulDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPodStatefulDto' is not null or undefined
            assertParamExists('createPod', 'createPodStatefulDto', createPodStatefulDto)
            const localVarPath = `/pods/stateful`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPodStatefulDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePod: async (podId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podId' is not null or undefined
            assertParamExists('deletePod', 'podId', podId)
            const localVarPath = `/pods/stateful/{podId}`
                .replace(`{${"podId"}}`, encodeURIComponent(String(podId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPodsByCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getPodsByCourse', 'courseId', courseId)
            const localVarPath = `/pods/stateful/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} resourceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPodsByResourceGroup: async (resourceGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceGroupId' is not null or undefined
            assertParamExists('getPodsByResourceGroup', 'resourceGroupId', resourceGroupId)
            const localVarPath = `/pods/stateful/resource-group/{resourceGroupId}`
                .replace(`{${"resourceGroupId"}}`, encodeURIComponent(String(resourceGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPodsByTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getPodsByTeam', 'teamId', teamId)
            const localVarPath = `/pods/stateful/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodStatefulControllerApi - functional programming interface
 * @export
 */
export const PodStatefulControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PodStatefulControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePodStatefulDto} createPodStatefulDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPod(createPodStatefulDto: CreatePodStatefulDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodStatefulDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPod(createPodStatefulDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.createPod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePod(podId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePod(podId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.deletePod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPodsByCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatefulDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPodsByCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getPodsByCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} resourceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPodsByResourceGroup(resourceGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatefulDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPodsByResourceGroup(resourceGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getPodsByResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPodsByTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodStatefulDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPodsByTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PodStatefulControllerApi.getPodsByTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PodStatefulControllerApi - factory interface
 * @export
 */
export const PodStatefulControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PodStatefulControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePodStatefulDto} createPodStatefulDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPod(createPodStatefulDto: CreatePodStatefulDto, options?: RawAxiosRequestConfig): AxiosPromise<PodStatefulDto> {
            return localVarFp.createPod(createPodStatefulDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} podId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePod(podId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePod(podId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPodsByCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatefulDto>> {
            return localVarFp.getPodsByCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} resourceGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPodsByResourceGroup(resourceGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatefulDto>> {
            return localVarFp.getPodsByResourceGroup(resourceGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPodsByTeam(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PodStatefulDto>> {
            return localVarFp.getPodsByTeam(teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PodStatefulControllerApi - object-oriented interface
 * @export
 * @class PodStatefulControllerApi
 * @extends {BaseAPI}
 */
export class PodStatefulControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreatePodStatefulDto} createPodStatefulDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public createPod(createPodStatefulDto: CreatePodStatefulDto, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).createPod(createPodStatefulDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} podId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public deletePod(podId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).deletePod(podId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getPodsByCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getPodsByCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} resourceGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getPodsByResourceGroup(resourceGroupId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getPodsByResourceGroup(resourceGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodStatefulControllerApi
     */
    public getPodsByTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return PodStatefulControllerApiFp(this.configuration).getPodsByTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PrivateNetworkControllerApi - axios parameter creator
 * @export
 */
export const PrivateNetworkControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachNicToNetwork: async (id: string, networkVmConnectionDto: NetworkVmConnectionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attachNicToNetwork', 'id', id)
            // verify required parameter 'networkVmConnectionDto' is not null or undefined
            assertParamExists('attachNicToNetwork', 'networkVmConnectionDto', networkVmConnectionDto)
            const localVarPath = `/network/{id}/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkVmConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNetwork', 'id', id)
            const localVarPath = `/network/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachNicFromNetwork: async (networkVmConnectionDto: NetworkVmConnectionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkVmConnectionDto' is not null or undefined
            assertParamExists('detachNicFromNetwork', 'networkVmConnectionDto', networkVmConnectionDto)
            const localVarPath = `/network/detach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkVmConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrivateNetworkControllerApi - functional programming interface
 * @export
 */
export const PrivateNetworkControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrivateNetworkControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachNicToNetwork(id: string, networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachNicToNetwork(id, networkVmConnectionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrivateNetworkControllerApi.attachNicToNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetwork(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetwork(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrivateNetworkControllerApi.deleteNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachNicFromNetwork(networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachNicFromNetwork(networkVmConnectionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrivateNetworkControllerApi.detachNicFromNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PrivateNetworkControllerApi - factory interface
 * @export
 */
export const PrivateNetworkControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrivateNetworkControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachNicToNetwork(id: string, networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.attachNicToNetwork(id, networkVmConnectionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNetwork(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NetworkVmConnectionDto} networkVmConnectionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachNicFromNetwork(networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.detachNicFromNetwork(networkVmConnectionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrivateNetworkControllerApi - object-oriented interface
 * @export
 * @class PrivateNetworkControllerApi
 * @extends {BaseAPI}
 */
export class PrivateNetworkControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {NetworkVmConnectionDto} networkVmConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrivateNetworkControllerApi
     */
    public attachNicToNetwork(id: string, networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig) {
        return PrivateNetworkControllerApiFp(this.configuration).attachNicToNetwork(id, networkVmConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrivateNetworkControllerApi
     */
    public deleteNetwork(id: string, options?: RawAxiosRequestConfig) {
        return PrivateNetworkControllerApiFp(this.configuration).deleteNetwork(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NetworkVmConnectionDto} networkVmConnectionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrivateNetworkControllerApi
     */
    public detachNicFromNetwork(networkVmConnectionDto: NetworkVmConnectionDto, options?: RawAxiosRequestConfig) {
        return PrivateNetworkControllerApiFp(this.configuration).detachNicFromNetwork(networkVmConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReservationControllerApi - axios parameter creator
 * @export
 */
export const ReservationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to create a new reservation for the team they are a part of.
         * @summary Create new reservation
         * @param {CreateReservationDto} createReservationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReservation: async (createReservationDto: CreateReservationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createReservationDto' is not null or undefined
            assertParamExists('createNewReservation', 'createReservationDto', createReservationDto)
            const localVarPath = `/reservations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReservationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishReservation: async (reservationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('finishReservation', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}/cancel`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservations: async (courseId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getActiveReservations', 'courseId', courseId)
            const localVarPath = `/reservations/active/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservationsForTeam: async (teamId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getActiveReservationsForTeam', 'teamId', teamId)
            const localVarPath = `/reservations/active/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservations: async (courseId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getHistoricReservations', 'courseId', courseId)
            const localVarPath = `/reservations/historic/courses/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservationsForTeam: async (teamId: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getHistoricReservationsForTeam', 'teamId', teamId)
            const localVarPath = `/reservations/historic/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservationDetails: async (reservationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('getReservationDetails', 'reservationId', reservationId)
            const localVarPath = `/reservations/{reservationId}`
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservationsForGivenPeriodForResourceGroup: async (rgId: string, start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getReservationsForGivenPeriodForResourceGroup', 'rgId', rgId)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getReservationsForGivenPeriodForResourceGroup', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getReservationsForGivenPeriodForResourceGroup', 'end', end)
            const localVarPath = `/reservations/period/{rgId}`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationControllerApi - functional programming interface
 * @export
 */
export const ReservationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint can be used to create a new reservation for the team they are a part of.
         * @summary Create new reservation
         * @param {CreateReservationDto} createReservationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewReservation(createReservationDto: CreateReservationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewReservation(createReservationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.createNewReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishReservation(reservationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishReservation(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.finishReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveReservations(courseId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getActiveReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveReservationsForTeam(teamId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getActiveReservationsForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricReservations(courseId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getHistoricReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDtoReservationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricReservationsForTeam(teamId, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getHistoricReservationsForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReservationDetails(reservationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReservationDetails(reservationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getReservationDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReservationsForGivenPeriodForResourceGroup(rgId: string, start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReservationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReservationsForGivenPeriodForResourceGroup(rgId, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReservationControllerApi.getReservationsForGivenPeriodForResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReservationControllerApi - factory interface
 * @export
 */
export const ReservationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationControllerApiFp(configuration)
    return {
        /**
         * This endpoint can be used to create a new reservation for the team they are a part of.
         * @summary Create new reservation
         * @param {CreateReservationDto} createReservationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReservation(createReservationDto: CreateReservationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewReservation(createReservationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishReservation(reservationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.finishReservation(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getActiveReservations(courseId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getActiveReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getHistoricReservations(courseId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDtoReservationDto> {
            return localVarFp.getHistoricReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservationDetails(reservationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReservationDetailsDto> {
            return localVarFp.getReservationDetails(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} start 
         * @param {string} end 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservationsForGivenPeriodForResourceGroup(rgId: string, start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReservationDto>> {
            return localVarFp.getReservationsForGivenPeriodForResourceGroup(rgId, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReservationControllerApi - object-oriented interface
 * @export
 * @class ReservationControllerApi
 * @extends {BaseAPI}
 */
export class ReservationControllerApi extends BaseAPI {
    /**
     * This endpoint can be used to create a new reservation for the team they are a part of.
     * @summary Create new reservation
     * @param {CreateReservationDto} createReservationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public createNewReservation(createReservationDto: CreateReservationDto, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).createNewReservation(createReservationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public finishReservation(reservationId: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).finishReservation(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getActiveReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getActiveReservations(courseId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getActiveReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getActiveReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getHistoricReservations(courseId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getHistoricReservations(courseId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getHistoricReservationsForTeam(teamId: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getHistoricReservationsForTeam(teamId, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getReservationDetails(reservationId: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getReservationDetails(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {string} start 
     * @param {string} end 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationControllerApi
     */
    public getReservationsForGivenPeriodForResourceGroup(rgId: string, start: string, end: string, options?: RawAxiosRequestConfig) {
        return ReservationControllerApiFp(this.configuration).getReservationsForGivenPeriodForResourceGroup(rgId, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroup: async (createResourceGroupDto: CreateResourceGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createResourceGroupDto' is not null or undefined
            assertParamExists('createResourceGroup', 'createResourceGroupDto', createResourceGroupDto)
            const localVarPath = `/resource-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResourceGroup', 'id', id)
            const localVarPath = `/resource-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceGroup(createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceGroup(createResourceGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupControllerApi.createResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupControllerApi.getResourceGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupControllerApi.getResourceGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupControllerApi - factory interface
 * @export
 */
export const ResourceGroupControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateResourceGroupDto} createResourceGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroup(createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupDto> {
            return localVarFp.createResourceGroup(createResourceGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupDto> {
            return localVarFp.getResourceGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupDto>> {
            return localVarFp.getResourceGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateResourceGroupDto} createResourceGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupControllerApi
     */
    public createResourceGroup(createResourceGroupDto: CreateResourceGroupDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupControllerApiFp(this.configuration).createResourceGroup(createResourceGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupControllerApi
     */
    public getResourceGroup(id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupControllerApiFp(this.configuration).getResourceGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupControllerApi
     */
    public getResourceGroups(options?: RawAxiosRequestConfig) {
        return ResourceGroupControllerApiFp(this.configuration).getResourceGroups(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupNetworkControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupNetworkControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResourceGroupNetwork: async (resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceGroupNetworkDto' is not null or undefined
            assertParamExists('addResourceGroupNetwork', 'resourceGroupNetworkDto', resourceGroupNetworkDto)
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('addResourceGroupNetwork', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/network`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resourceGroupNetworkDto !== undefined) {
                for (const [key, value] of Object.entries(resourceGroupNetworkDto)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('get', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/network`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupNetworkControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupNetworkControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupNetworkControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addResourceGroupNetwork(resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupNetworkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addResourceGroupNetwork(resourceGroupNetworkDto, rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupNetworkControllerApi.addResourceGroupNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceGroupNetworkDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupNetworkControllerApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupNetworkControllerApi - factory interface
 * @export
 */
export const ResourceGroupNetworkControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupNetworkControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addResourceGroupNetwork(resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupNetworkDto> {
            return localVarFp.addResourceGroupNetwork(resourceGroupNetworkDto, rgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourceGroupNetworkDto>> {
            return localVarFp.get(rgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupNetworkControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupNetworkControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupNetworkControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateResourceGroupNetworkDto} resourceGroupNetworkDto 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupNetworkControllerApi
     */
    public addResourceGroupNetwork(resourceGroupNetworkDto: CreateResourceGroupNetworkDto, rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupNetworkControllerApiFp(this.configuration).addResourceGroupNetwork(resourceGroupNetworkDto, rgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupNetworkControllerApi
     */
    public get(rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupNetworkControllerApiFp(this.configuration).get(rgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupPoolControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupPoolControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateRGPoolDto} createRGPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroupPool: async (createRGPoolDto: CreateRGPoolDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRGPoolDto' is not null or undefined
            assertParamExists('createResourceGroupPool', 'createRGPoolDto', createRGPoolDto)
            const localVarPath = `/resource-group-pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRGPoolDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPool: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResourceGroupPool', 'id', id)
            const localVarPath = `/resource-group-pool/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPools: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-group-pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupPoolControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupPoolControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupPoolControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateRGPoolDto} createRGPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceGroupPool(createRGPoolDto: CreateRGPoolDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceGroupPoolDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceGroupPool(createRGPoolDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.createResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroupPool(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedResourceGroupPoolDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroupPool(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.getResourceGroupPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceGroupPools(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailedResourceGroupPoolDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceGroupPools(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupPoolControllerApi.getResourceGroupPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupPoolControllerApi - factory interface
 * @export
 */
export const ResourceGroupPoolControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupPoolControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateRGPoolDto} createRGPoolDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceGroupPool(createRGPoolDto: CreateRGPoolDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceGroupPoolDto> {
            return localVarFp.createResourceGroupPool(createRGPoolDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPool(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedResourceGroupPoolDto> {
            return localVarFp.getResourceGroupPool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroupPools(options?: RawAxiosRequestConfig): AxiosPromise<Array<DetailedResourceGroupPoolDto>> {
            return localVarFp.getResourceGroupPools(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupPoolControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupPoolControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupPoolControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateRGPoolDto} createRGPoolDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public createResourceGroupPool(createRGPoolDto: CreateRGPoolDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).createResourceGroupPool(createRGPoolDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public getResourceGroupPool(id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).getResourceGroupPool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupPoolControllerApi
     */
    public getResourceGroupPools(options?: RawAxiosRequestConfig) {
        return ResourceGroupPoolControllerApiFp(this.configuration).getResourceGroupPools(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceGroupVmControllerApi - axios parameter creator
 * @export
 */
export const ResourceGroupVmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} rgId 
         * @param {AddVmDto} addVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVm: async (rgId: string, addVmDto: AddVmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('addVm', 'rgId', rgId)
            // verify required parameter 'addVmDto' is not null or undefined
            assertParamExists('addVm', 'addVmDto', addVmDto)
            const localVarPath = `/resource-group/{rgId}/vm`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVm: async (rgId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('deleteVm', 'rgId', rgId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVm', 'id', id)
            const localVarPath = `/resource-group/{rgId}/vm/{id}`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm1: async (rgId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getVm1', 'rgId', rgId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVm1', 'id', id)
            const localVarPath = `/resource-group/{rgId}/vm/{id}`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms: async (rgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rgId' is not null or undefined
            assertParamExists('getVms', 'rgId', rgId)
            const localVarPath = `/resource-group/{rgId}/vm`
                .replace(`{${"rgId"}}`, encodeURIComponent(String(rgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceGroupVmControllerApi - functional programming interface
 * @export
 */
export const ResourceGroupVmControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceGroupVmControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} rgId 
         * @param {AddVmDto} addVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVm(rgId: string, addVmDto: AddVmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVm(rgId, addVmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.addVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVm(rgId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVm(rgId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.deleteVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVm1(rgId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVm1(rgId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.getVm1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVms(rgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVms(rgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceGroupVmControllerApi.getVms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceGroupVmControllerApi - factory interface
 * @export
 */
export const ResourceGroupVmControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceGroupVmControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} rgId 
         * @param {AddVmDto} addVmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVm(rgId: string, addVmDto: AddVmDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addVm(rgId, addVmDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVm(rgId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVm(rgId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm1(rgId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<VmDto> {
            return localVarFp.getVm1(rgId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms(rgId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VmDto>> {
            return localVarFp.getVms(rgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceGroupVmControllerApi - object-oriented interface
 * @export
 * @class ResourceGroupVmControllerApi
 * @extends {BaseAPI}
 */
export class ResourceGroupVmControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} rgId 
     * @param {AddVmDto} addVmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public addVm(rgId: string, addVmDto: AddVmDto, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).addVm(rgId, addVmDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public deleteVm(rgId: string, id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).deleteVm(rgId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public getVm1(rgId: string, id: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).getVm1(rgId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceGroupVmControllerApi
     */
    public getVms(rgId: string, options?: RawAxiosRequestConfig) {
        return ResourceGroupVmControllerApiFp(this.configuration).getVms(rgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamControllerApi - axios parameter creator
 * @export
 */
export const TeamControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTeamDto} createTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamDto: CreateTeamDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamDto' is not null or undefined
            assertParamExists('createTeam', 'createTeamDto', createTeamDto)
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTeamsByCourse', 'courseId', courseId)
            const localVarPath = `/api/v1/teams/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTeamsByUser', 'userId', userId)
            const localVarPath = `/api/v1/teams/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeam: async (key: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('joinTeam', 'key', key)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('joinTeam', 'userId', userId)
            const localVarPath = `/api/v1/teams/join/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamControllerApi - functional programming interface
 * @export
 */
export const TeamControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTeamDto} createTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamDto: CreateTeamDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.createTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsByCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsByCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeamsByCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsByUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsByUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.getTeamsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinTeam(key: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinTeam(key, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamControllerApi.joinTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamControllerApi - factory interface
 * @export
 */
export const TeamControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTeamDto} createTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamDto: CreateTeamDto, options?: RawAxiosRequestConfig): AxiosPromise<TeamDto> {
            return localVarFp.createTeam(createTeamDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<TeamDto> {
            return localVarFp.getTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamDto>> {
            return localVarFp.getTeams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamDto>> {
            return localVarFp.getTeamsByCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamDto>> {
            return localVarFp.getTeamsByUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeam(key: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<TeamDto> {
            return localVarFp.joinTeam(key, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamControllerApi - object-oriented interface
 * @export
 * @class TeamControllerApi
 * @extends {BaseAPI}
 */
export class TeamControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateTeamDto} createTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public createTeam(createTeamDto: CreateTeamDto, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).createTeam(createTeamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeams(options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeamsByCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeamsByCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public getTeamsByUser(userId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).getTeamsByUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamControllerApi
     */
    public joinTeam(key: string, userId: string, options?: RawAxiosRequestConfig) {
        return TeamControllerApiFp(this.configuration).joinTeam(key, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSimpleMail: async (mailTo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailTo' is not null or undefined
            assertParamExists('sendSimpleMail', 'mailTo', mailTo)
            const localVarPath = `/test/send-simple-mail/{mail-to}`
                .replace(`{${"mail-to"}}`, encodeURIComponent(String(mailTo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSimpleMail(mailTo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendSimpleMail(mailTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.sendSimpleMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} mailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSimpleMail(mailTo: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.sendSimpleMail(mailTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} mailTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public sendSimpleMail(mailTo: string, options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).sendSimpleMail(mailTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VlansRangeControllerApi - axios parameter creator
 * @export
 */
export const VlansRangeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateVlansRangeDto} createVlansRangeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVlansRange: async (createVlansRangeDto: CreateVlansRangeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVlansRangeDto' is not null or undefined
            assertParamExists('addVlansRange', 'createVlansRangeDto', createVlansRangeDto)
            const localVarPath = `/resources/vnic-profiles/vlans-range/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVlansRangeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRange: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVlansRange', 'id', id)
            const localVarPath = `/resources/vnic-profiles/vlans-range/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [sorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRanges: async (sorted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles/vlans-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sorted !== undefined) {
                localVarQueryParameter['sorted'] = sorted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVlansRange: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeVlansRange', 'id', id)
            const localVarPath = `/resources/vnic-profiles/vlans-range/{id}/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VlansRangeControllerApi - functional programming interface
 * @export
 */
export const VlansRangeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VlansRangeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateVlansRangeDto} createVlansRangeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVlansRange(createVlansRangeDto: CreateVlansRangeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VlansRangeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVlansRange(createVlansRangeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.addVlansRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVlansRange(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VlansRangeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVlansRange(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.getVlansRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [sorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVlansRanges(sorted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VlansRangeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVlansRanges(sorted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.getVlansRanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVlansRange(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeVlansRange(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VlansRangeControllerApi.removeVlansRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VlansRangeControllerApi - factory interface
 * @export
 */
export const VlansRangeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VlansRangeControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateVlansRangeDto} createVlansRangeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVlansRange(createVlansRangeDto: CreateVlansRangeDto, options?: RawAxiosRequestConfig): AxiosPromise<VlansRangeDto> {
            return localVarFp.addVlansRange(createVlansRangeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRange(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VlansRangeDto> {
            return localVarFp.getVlansRange(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [sorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVlansRanges(sorted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<VlansRangeDto>> {
            return localVarFp.getVlansRanges(sorted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVlansRange(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeVlansRange(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VlansRangeControllerApi - object-oriented interface
 * @export
 * @class VlansRangeControllerApi
 * @extends {BaseAPI}
 */
export class VlansRangeControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateVlansRangeDto} createVlansRangeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public addVlansRange(createVlansRangeDto: CreateVlansRangeDto, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).addVlansRange(createVlansRangeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public getVlansRange(id: string, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).getVlansRange(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [sorted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public getVlansRanges(sorted?: boolean, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).getVlansRanges(sorted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VlansRangeControllerApi
     */
    public removeVlansRange(id: string, options?: RawAxiosRequestConfig) {
        return VlansRangeControllerApiFp(this.configuration).removeVlansRange(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VmControllerApi - axios parameter creator
 * @export
 */
export const VmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsForVm: async (id: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findEventsForVm', 'id', id)
            const localVarPath = `/resource/vm/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVmRequiredResources: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findVmRequiredResources', 'id', id)
            const localVarPath = `/resource/vm/{id}/required-resources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVm', 'id', id)
            const localVarPath = `/resource/vm/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource/vm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmControllerApi - functional programming interface
 * @export
 */
export const VmControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventsForVm(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventGeneralDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findEventsForVm(id, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.findEventsForVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findVmRequiredResources(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourcesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findVmRequiredResources(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.findVmRequiredResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVm(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVm(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.getVm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVms1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVms1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VmControllerApi.getVms1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VmControllerApi - factory interface
 * @export
 */
export const VmControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventsForVm(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventGeneralDto>> {
            return localVarFp.findEventsForVm(id, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findVmRequiredResources(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourcesDto> {
            return localVarFp.findVmRequiredResources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VmDto> {
            return localVarFp.getVm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VmDto>> {
            return localVarFp.getVms1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmControllerApi - object-oriented interface
 * @export
 * @class VmControllerApi
 * @extends {BaseAPI}
 */
export class VmControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public findEventsForVm(id: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).findEventsForVm(id, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public findVmRequiredResources(id: string, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).findVmRequiredResources(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public getVm(id: string, options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).getVm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmControllerApi
     */
    public getVms1(options?: RawAxiosRequestConfig) {
        return VmControllerApiFp(this.configuration).getVms1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VnicProfileControllerApi - axios parameter creator
 * @export
 */
export const VnicProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendVnicProfilesPool: async (vnicProfileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vnicProfileId' is not null or undefined
            assertParamExists('extendVnicProfilesPool', 'vnicProfileId', vnicProfileId)
            const localVarPath = `/resources/vnic-profiles/eduvirt/add-to-pool/{vnicProfileId}`
                .replace(`{${"vnicProfileId"}}`, encodeURIComponent(String(vnicProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvirtVnicProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles/ovirt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynchronizedVnicProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfileFromPool: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVnicProfileFromPool', 'id', id)
            const localVarPath = `/resources/vnic-profiles/eduvirt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfilesFromPool: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/vnic-profiles/eduvirt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reduceVnicProfilesPool: async (vnicProfileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vnicProfileId' is not null or undefined
            assertParamExists('reduceVnicProfilesPool', 'vnicProfileId', vnicProfileId)
            const localVarPath = `/resources/vnic-profiles/eduvirt/remove-from-pool/{vnicProfileId}`
                .replace(`{${"vnicProfileId"}}`, encodeURIComponent(String(vnicProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VnicProfileControllerApi - functional programming interface
 * @export
 */
export const VnicProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VnicProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VnicProfilePoolMemberDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendVnicProfilesPool(vnicProfileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.extendVnicProfilesPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOvirtVnicProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VnicProfileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOvirtVnicProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getOvirtVnicProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSynchronizedVnicProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VnicProfileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSynchronizedVnicProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getSynchronizedVnicProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVnicProfileFromPool(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VnicProfilePoolMemberDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVnicProfileFromPool(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getVnicProfileFromPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVnicProfilesFromPool(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VnicProfilePoolMemberDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVnicProfilesFromPool(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.getVnicProfilesFromPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reduceVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reduceVnicProfilesPool(vnicProfileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VnicProfileControllerApi.reduceVnicProfilesPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VnicProfileControllerApi - factory interface
 * @export
 */
export const VnicProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VnicProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): AxiosPromise<VnicProfilePoolMemberDto> {
            return localVarFp.extendVnicProfilesPool(vnicProfileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvirtVnicProfiles(options?: RawAxiosRequestConfig): AxiosPromise<Array<VnicProfileDto>> {
            return localVarFp.getOvirtVnicProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSynchronizedVnicProfiles(options?: RawAxiosRequestConfig): AxiosPromise<Array<VnicProfileDto>> {
            return localVarFp.getSynchronizedVnicProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfileFromPool(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VnicProfilePoolMemberDto> {
            return localVarFp.getVnicProfileFromPool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVnicProfilesFromPool(options?: RawAxiosRequestConfig): AxiosPromise<Array<VnicProfilePoolMemberDto>> {
            return localVarFp.getVnicProfilesFromPool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} vnicProfileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reduceVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reduceVnicProfilesPool(vnicProfileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VnicProfileControllerApi - object-oriented interface
 * @export
 * @class VnicProfileControllerApi
 * @extends {BaseAPI}
 */
export class VnicProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} vnicProfileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public extendVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).extendVnicProfilesPool(vnicProfileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getOvirtVnicProfiles(options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getOvirtVnicProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getSynchronizedVnicProfiles(options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getSynchronizedVnicProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getVnicProfileFromPool(id: string, options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getVnicProfileFromPool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public getVnicProfilesFromPool(options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).getVnicProfilesFromPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} vnicProfileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VnicProfileControllerApi
     */
    public reduceVnicProfilesPool(vnicProfileId: string, options?: RawAxiosRequestConfig) {
        return VnicProfileControllerApiFp(this.configuration).reduceVnicProfilesPool(vnicProfileId, options).then((request) => request(this.axios, this.basePath));
    }
}



